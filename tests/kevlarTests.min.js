/*!
 * Kevlar JS Library
 * Copyright(c) 2011 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
(function(){tests.unit=new Ext.test.TestSuite("unit");tests.unit.attribute=new Ext.test.TestSuite("attribute").addTo(tests.unit);tests.unit.data=new Ext.test.TestSuite("data").addTo(tests.unit);tests.unit.persistence=new Ext.test.TestSuite("persistence").addTo(tests.unit);tests.unit.util=new Ext.test.TestSuite("util").addTo(tests.unit);Ext.test.Session.addSuite(tests.unit)})();tests.unit.add(new Ext.test.TestSuite({name:"Kevlar",items:[{name:"Test isArray()",test_isArray:function(){var a=Kevlar.extend(Object,{length:1});Y.Assert.isTrue(Kevlar.isArray([]),"Test with empty array");Y.Assert.isTrue(Kevlar.isArray([1,2,3,4]),"Test with filled array");Y.Assert.isFalse(Kevlar.isArray(false),"Test with boolean #1");Y.Assert.isFalse(Kevlar.isArray(true),"Test with boolean #2");Y.Assert.isFalse(Kevlar.isArray("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isArray(1),"Test with number");Y.Assert.isFalse(Kevlar.isArray(null),"Test with null");Y.Assert.isFalse(Kevlar.isArray(new Date()),"Test with a date");Y.Assert.isFalse(Kevlar.isArray({}),"Test with empty object");Y.Assert.isFalse(Kevlar.isArray(document.getElementsByTagName("body")),"Test with node list");Y.Assert.isFalse(Kevlar.isArray(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isArray(new a()),"Test with custom class that has a length property")}},{name:"Test isBoolean()",test_isBoolean:function(){Y.Assert.isTrue(Kevlar.isBoolean(true),"Test with true");Y.Assert.isTrue(Kevlar.isBoolean(false),"Test with false");Y.Assert.isFalse(Kevlar.isBoolean([]),"Test with empty array");Y.Assert.isFalse(Kevlar.isBoolean([1,2,3]),"Test with filled array");Y.Assert.isFalse(Kevlar.isBoolean(1),"Test with number");Y.Assert.isFalse(Kevlar.isBoolean(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isBoolean("foo"),"Test with non empty string");Y.Assert.isFalse(Kevlar.isBoolean(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isBoolean(null),"Test with null");Y.Assert.isFalse(Kevlar.isBoolean({}),"Test with object");Y.Assert.isFalse(Kevlar.isBoolean(new Date()),"Test with date")}},{name:"Test isDate()",test_isDate:function(){Y.Assert.isTrue(Kevlar.isDate(new Date()),"Test with simple date");Y.Assert.isTrue(Kevlar.isDate(Date.parseDate("2000","Y")),"Test with simple date");Y.Assert.isFalse(Kevlar.isDate(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isDate(1),"Test with number");Y.Assert.isFalse(Kevlar.isDate("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isDate(null),"Test with null");Y.Assert.isFalse(Kevlar.isDate([]),"Test with array");Y.Assert.isFalse(Kevlar.isDate({}),"Test with object");Y.Assert.isFalse(Kevlar.isDate(jQuery("body")[0]),"Test with element")}},{name:"Test isDefined()",test_isDefined:function(){Y.Assert.isFalse(Kevlar.isDefined(undefined),"Test with undefined");Y.Assert.isTrue(Kevlar.isDefined(null),"Test with null");Y.Assert.isTrue(Kevlar.isDefined({}),"Test with object");Y.Assert.isTrue(Kevlar.isDefined([]),"Test with array");Y.Assert.isTrue(Kevlar.isDefined(new Date()),"Test with date");Y.Assert.isTrue(Kevlar.isDefined(1),"Test with number");Y.Assert.isTrue(Kevlar.isDefined(false),"Test with boolean");Y.Assert.isTrue(Kevlar.isDefined(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isDefined("foo"),"Test with non-empty string");Y.Assert.isTrue(Kevlar.isDefined(jQuery("body")[0]),"Test with element")}},{name:"Test isElement()",test_isElement:function(){Y.Assert.isTrue(Kevlar.isElement(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isElement(null),"Test with null");Y.Assert.isFalse(Kevlar.isElement(1),"Test with number");Y.Assert.isFalse(Kevlar.isElement("foo"),"Test with string")}},{name:"Test isJQuery()",test_isJQuery:function(){Y.Assert.isFalse(Kevlar.isJQuery(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isJQuery(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isJQuery(null),"Test with null");Y.Assert.isFalse(Kevlar.isJQuery(1),"Test with number");Y.Assert.isFalse(Kevlar.isJQuery("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isJQuery(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isJQuery({}),"Test with anonymous object");Y.Assert.isFalse(Kevlar.isJQuery(Kevlar.emptyFn),"Test with function");Y.Assert.isFalse(Kevlar.isJQuery([]),"Test with array");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("body")),"Test with jQuery wrapped set object, with an element");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("#non-existent-element")),"Test with jQuery wrapped set object, without any elements")}},{name:"Test isFunction()",test_isFunction:function(){var b=new Kevlar.util.Observable(),a={fn:function(){}};Y.Assert.isTrue(Kevlar.isFunction(function(){}),"Test with anonymous function");Y.Assert.isTrue(Kevlar.isFunction(new Function('return "";')),"Test with new Function syntax");Y.Assert.isTrue(Kevlar.isFunction(Kevlar.emptyFn),"Test with static function");Y.Assert.isTrue(Kevlar.isFunction(b.fireEvent),"Test with instance function");Y.Assert.isTrue(Kevlar.isFunction(a.fn),"Test with function on object");Y.Assert.isFalse(Kevlar.isFunction(Kevlar.version),"Test with class property");Y.Assert.isFalse(Kevlar.isFunction(null),"Test with null");Y.Assert.isFalse(Kevlar.isFunction(1),"Test with number");Y.Assert.isFalse(Kevlar.isFunction(""),"Test with string");Y.Assert.isFalse(Kevlar.isFunction(new Date()),"Test with date");Y.Assert.isFalse(Kevlar.isFunction([]),"Test with array");Y.Assert.isFalse(Kevlar.isFunction({}),"Test with object")}},{name:"Test isNumber()",test_isNumber:function(){Y.Assert.isTrue(Kevlar.isNumber(0),"Test with 0");Y.Assert.isTrue(Kevlar.isNumber(4),"Test with non-zero integer");Y.Assert.isTrue(Kevlar.isNumber(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isNumber(7.9),"Test with positive float");Y.Assert.isTrue(Kevlar.isNumber(-4.3),"Test with negative float");Y.Assert.isTrue(Kevlar.isNumber(Number.MAX_VALUE),"Test with MAX_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Number.MIN_VALUE),"Test with MIN_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isNumber(Number("3.1")),"Test with Number() constructor");Y.Assert.isFalse(Kevlar.isNumber(Number.NaN),"Test with NaN");Y.Assert.isFalse(Kevlar.isNumber(Number.POSITIVE_INFINITY),"Test with POSITIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(Number.NEGATIVE_INFINITY),"Test with NEGATIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(true),"Test with true");Y.Assert.isFalse(Kevlar.isNumber(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isNumber("1.0"),"Test with string containing a number");Y.Assert.isFalse(Kevlar.isNumber(null),"Test with null");Y.Assert.isFalse(Kevlar.isNumber(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isNumber([]),"Test with array");Y.Assert.isFalse(Kevlar.isNumber({}),"Test with object")}},{name:"Test isObject()",test_isObject:function(){Y.Assert.isTrue(Kevlar.isObject({}),"Test with empty object");Y.Assert.isTrue(Kevlar.isObject({foo:1}),"Test with object with properties");Y.Assert.isTrue(Kevlar.isObject(new Kevlar.util.Observable()),"Test with object instance");Y.Assert.isTrue(Kevlar.isObject(new Object()),"Test with new Object(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(new Date()),"Test with a date object");Y.Assert.isFalse(Kevlar.isObject([]),"Test with array");Y.Assert.isFalse(Kevlar.isObject(new Array()),"Test with new Array(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(1),"Test with number");Y.Assert.isFalse(Kevlar.isObject("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isObject(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isObject(new Number(3)),"Test with new Number() syntax");Y.Assert.isFalse(Kevlar.isObject(new String("foo")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isObject(null),"Test with null");Y.Assert.isFalse(Kevlar.isObject(undefined),"Test with undefined")}},{name:"Test isPrimitive()",test_isPrimitive:function(){Y.Assert.isTrue(Kevlar.isPrimitive(1),"Test with integer");Y.Assert.isTrue(Kevlar.isPrimitive(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isPrimitive(1.4),"Test with floating number");Y.Assert.isTrue(Kevlar.isPrimitive(Number.MAX_VALUE),"Test with Number.MAX_VALUE");Y.Assert.isTrue(Kevlar.isPrimitive(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isPrimitive(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isPrimitive("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isPrimitive(true),"Test with boolean true");Y.Assert.isTrue(Kevlar.isPrimitive(false),"Test with boolean false");Y.Assert.isFalse(Kevlar.isPrimitive(null),"Test with null");Y.Assert.isFalse(Kevlar.isPrimitive(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isPrimitive({}),"Test with object");Y.Assert.isFalse(Kevlar.isPrimitive([]),"Test with array");Y.Assert.isFalse(Kevlar.isPrimitive(new Kevlar.util.Observable()),"Test with object instance")}},{name:"Test isString()",test_isString:function(){var a=new String("foo");Y.Assert.isTrue(Kevlar.isString(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isString("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isString(String("")),"Test with String() syntax");Y.Assert.isFalse(Kevlar.isString(new String("")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isString(1),"Test with number");Y.Assert.isFalse(Kevlar.isString(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isString(null),"Test with null");Y.Assert.isFalse(Kevlar.isString(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isString([]),"Test with array");Y.Assert.isFalse(Kevlar.isString({}),"Test with number")}},{name:"Test namespace()",test_namespace:function(){var a=window;Kevlar.namespace("FooTest1");Y.Assert.isNotUndefined(a.FooTest1,"Test creation with a single top-level namespace");Kevlar.namespace("FooTest2","FooTest3","FooTest4");Y.Assert.isNotUndefined(a.FooTest2,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest3,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest4,"Test creation with multiple top level namespaces");Kevlar.namespace("FooTest5","FooTest5.ns1","FooTest5.ns1.ns2","FooTest5.ns1.ns2.ns3");Y.Assert.isNotUndefined(a.FooTest5,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2.ns3,"Test a chain of namespaces, starting from a top-level");Kevlar.namespace("FooTest6.ns1","FooTest7.ns1");Y.Assert.isNotUndefined(a.FooTest6.ns1,"Test creating lower level namespaces without first defining the top level");Y.Assert.isNotUndefined(a.FooTest7.ns1,"Test creating lower level namespaces without first defining the top level");Kevlar.namespace("FooTest8","FooTest8.ns1.ns2");Y.Assert.isNotUndefined(a.FooTest8,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1.ns2,"Test creating a lower level namespace without defining the middle level");FooTest8.prop1="foo";Kevlar.namespace("FooTest8");Y.Assert.areEqual("foo",FooTest8.prop1,"Ensure existing namespaces are not overwritten")}},{name:"Test toArray()",test_toArray:function(){Y.Assert.isArray(Kevlar.toArray(document.getElementsByTagName("body")),"Test with node list");(function(){var a=Kevlar.toArray(arguments);Y.Assert.isArray(a,"Test with arguments object");Y.Assert.areSame(3,a.length,"Should be 3 args in the array")})(1,2,3)}}]}));tests.unit.attribute.add(new Ext.test.TestCase({name:"Kevlar.attribute.Attribute",setUp:function(){},_should:{error:{"Instantiating an Attribute without a 'name' should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with an undefined 'name' argument should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with an undefined 'name' property should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with a null 'name' argument should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with a null 'name' property should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with an empty 'name' argument should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor","Instantiating an Attribute with an empty 'name' property should throw an error":"no 'name' property provided to Kevlar.attribute.Attribute constructor"}},"Instantiating an Attribute without a 'name' should throw an error":function(){var a=new Kevlar.attribute.Attribute()},"Instantiating an Attribute with an undefined 'name' argument should throw an error":function(){var a=new Kevlar.attribute.Attribute(undefined)},"Instantiating an Attribute with an undefined 'name' property should throw an error":function(){var a=new Kevlar.attribute.Attribute({name:undefined})},"Instantiating an Attribute with a null 'name' argument should throw an error":function(){var a=new Kevlar.attribute.Attribute(null)},"Instantiating an Attribute with a null 'name' property should throw an error":function(){var a=new Kevlar.attribute.Attribute({name:null})},"Instantiating an Attribute with an empty 'name' argument should throw an error":function(){var a=new Kevlar.attribute.Attribute("")},"Instantiating an Attribute with an empty 'name' property should throw an error":function(){var a=new Kevlar.attribute.Attribute({name:""})},"The name property should be retrievable by getName()":function(){var c=new Kevlar.attribute.Attribute({name:"testName"});Y.Assert.areSame("testName",c.getName(),"getName() not properly retriving Attribute's name. Was looking for 'testName'.");var b=new Kevlar.attribute.Attribute({name:"_"});Y.Assert.areSame("_",b.getName(),"getName() not properly retriving Attribute's name. Was looking for '_'.");var a=new Kevlar.attribute.Attribute({name:"abc"});Y.Assert.areSame("abc",a.getName(),"getName() not properly retriving Attribute's name. Was looking for 'abc'.")},"Providing the attribute name as a number directly to the constructor argument should be converted to a string for the attribute's name":function(){var a=new Kevlar.attribute.Attribute(0);Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")},"Providing the attribute name as a property on the config should be converted to a string for the attribute's name":function(){var a=new Kevlar.attribute.Attribute({name:0});Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")},"A default provided as the keyword 'default' should be accepted properly as defaultValue":function(){var a=new Kevlar.attribute.Attribute({name:"TestAttribute","default":1});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as the keyword 'default' that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.attribute.Attribute({name:"TestAttribute","default":function(){return 1}});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue should be accepted properly":function(){var a=new Kevlar.attribute.Attribute({name:"TestAttribute",defaultValue:1});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.attribute.Attribute({name:"TestAttribute",defaultValue:function(){return 1}});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue that is a function should be executed each time the default is called for":function(){var a=0;var b=new Kevlar.attribute.Attribute({name:"TestAttribute",defaultValue:function(){return ++a}});Y.Assert.areSame(1,b.getDefaultValue());Y.Assert.areSame(2,b.getDefaultValue())},"A defaultValue provided as an object should be recursed for functions, and those functions' return values should be used in the default":function(){var b=new Kevlar.attribute.Attribute({name:"TestAttribute","default":{a:"A",b:{innerB1:function(){return"B1"},innerB2:"B2"},c:{innerC1:"C",innerC2:function(){return"C2"}}}});var a=b.getDefaultValue();Y.Assert.areSame("A",a.a,"The 'default' config provided as an object should have had the value 'A' for property 'a'.");Y.Assert.areSame("B1",a.b.innerB1,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.");Y.Assert.areSame("C2",a.c.innerC2,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.")}}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Kevlar.attribute.CollectionAttribute",items:[{name:"Test constructor",_should:{error:{"the constructor should throw an error if the undefined value is provided for the collectionClass config, which helps determine when late binding is needed for the collectionClass config":"The 'collectionClass' config provided to an Attribute with the name 'attr' either doesn't exist, or doesn't exist just yet. Consider using the String or Function form of the collectionClass config for late binding, if needed"}},"the constructor should throw an error if the undefined value is provided for the collectionClass config, which helps determine when late binding is needed for the collectionClass config":function(){var a=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:undefined});Y.Assert.fail("The constructor should have thrown an error if the collectionClass config was provided but was undefined. This is to help with debugging when late binding for the collectionClass is needed.")}},{name:"Test valuesAreEqual()",setUp:function(){this.attribute=new Kevlar.attribute.CollectionAttribute({name:"attr"})},"valuesAreEqual() should return true for two null values":function(){var a=this.attribute.valuesAreEqual(null,null);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for one null and one object":function(){var a;a=this.attribute.valuesAreEqual(null,{});Y.Assert.isFalse(a);a=this.attribute.valuesAreEqual({},null);Y.Assert.isFalse(a)},"valuesAreEqual() should return true for comparing the same collection":function(){var b=Kevlar.Collection.extend({}),c=new b();var a=this.attribute.valuesAreEqual(c,c);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for two different collections":function(){var c=Kevlar.Collection.extend({}),d=new c(),b=new c();var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isFalse(a)}},{name:"Test beforeSet()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr1","attr2"]});this.Collection=Kevlar.Collection.extend({model:this.Model});this.attribute=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:this.Collection})},_should:{error:{"beforeSet() should throw an error if the string 'collectionClass' config does not reference a Collection class":"The string value 'collectionClass' config did not resolve to a Collection class for attribute 'attr'","beforeSet() should throw an error if the function value 'collectionClass' config does not reference a Collection class":"The function value 'collectionClass' config did not resolve to a Collection class for attribute 'attr'"}},"beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Kevlar.Model),c=new Kevlar.attribute.CollectionAttribute({name:"attr"}),b,d;d=c.beforeSet(a,b,0);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,1);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,"");Y.Assert.areSame(null,d);d=c.beforeSet(a,b,"hi");Y.Assert.areSame(null,d);d=c.beforeSet(a,b,false);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,true);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,undefined);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,null);Y.Assert.areSame(null,d)},"beforeSet() should throw an error if the string 'collectionClass' config does not reference a Collection class":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:"somethingThatIsNotDefined"});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,b,e);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should throw an error if the function value 'collectionClass' config does not reference a Collection class":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:function(){return}});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,b,e);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should convert an array of data objects, when collectionClass is a direct reference to the Collection subclass":function(){var a=JsMockito.mock(Kevlar.Model),d=[{attr1:1,attr2:2},{attr1:3,attr2:4}],b,c=this.attribute.beforeSet(a,b,d);Y.Assert.isInstanceOf(this.Collection,c,"The return value from beforeSet should have been an instance of the Collection");var f=c.getAt(0),e=c.getAt(1);Y.Assert.areSame(1,f.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,f.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,e.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,e.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should convert an array of data objects, when collectionClass is a string":function(){window.__Kevlar_CollectionAttributeTest={};window.__Kevlar_CollectionAttributeTest.ns1={};window.__Kevlar_CollectionAttributeTest.ns1.ns2={};window.__Kevlar_CollectionAttributeTest.ns1.ns2.MyCollection=Kevlar.Collection.extend({model:this.Model});var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:"__Kevlar_CollectionAttributeTest.ns1.ns2.MyCollection"});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,b,e);Y.Assert.isInstanceOf(window.__Kevlar_CollectionAttributeTest.ns1.ns2.MyCollection,d,"The return value from beforeSet should have been an instance of the Collection");var g=d.getAt(0),f=d.getAt(1);Y.Assert.areSame(1,g.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,g.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,f.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,f.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should convert an array of data objects, when collectionClass is a function":function(){var f=Kevlar.Collection.extend({model:this.Model});var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.CollectionAttribute({name:"attr",collectionClass:function(){return f}});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,b,e);Y.Assert.isInstanceOf(f,d,"The return value from beforeSet should have been an instance of the Collection");var h=d.getAt(0),g=d.getAt(1);Y.Assert.areSame(1,h.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,h.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,g.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,g.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should return an actual Collection instance unchanged":function(){var a=JsMockito.mock(Kevlar.Model),c,e=new this.Collection([{attr1:1,attr2:2}]),d=this.attribute.beforeSet(a,c,e);Y.Assert.areSame(e,d,"The return value from beforeSet should have been the same collection instance");var b=d.getAt(0);Y.Assert.areSame(1,b.get("attr1"),"The data should remain set to the new model");Y.Assert.areSame(2,b.get("attr2"),"The data should remain set to the new model")},"if no collectionClass was provided, beforeSet() should return an array unchanged":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.CollectionAttribute({name:"attr"});var e=[{attr1:1,attr2:2}],d=c.beforeSet(a,b,e);Y.Assert.areSame(e,d)}},{name:"Test afterSet()","afterSet() should return the collection (i.e. it doesn't forget the return statement!)":function(){var b=JsMockito.mock(Kevlar.Model),a=JsMockito.mock(Kevlar.Collection);var c=new Kevlar.attribute.CollectionAttribute({name:"attr"});var d=c.afterSet(b,a);Y.Assert.areSame(a,d)}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Kevlar.attribute.ModelAttribute",items:[{name:"Test constructor",_should:{error:{"the constructor should throw an error if the undefined value is provided for the modelClass config, which helps determine when late binding is needed for the modelClass config":"The 'modelClass' config provided to an Attribute with the name 'attr' either doesn't exist, or doesn't exist just yet. Consider using the String or Function form of the modelClass config for late binding, if needed"}},"the constructor should throw an error if the undefined value is provided for the modelClass config, which helps determine when late binding is needed for the modelClass config":function(){var a=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:undefined});Y.Assert.fail("The constructor should have thrown an error if the modelClass config was provided but was undefined. This is to help with debugging when late binding for the modelClass is needed.")}},{name:"Test valuesAreEqual()",setUp:function(){this.attribute=new Kevlar.attribute.ModelAttribute({name:"attr"})},"valuesAreEqual() should return true for two null values":function(){var a=this.attribute.valuesAreEqual(null,null);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for one null and one object":function(){var a=this.attribute.valuesAreEqual(null,{});Y.Assert.isFalse(a);var a=this.attribute.valuesAreEqual({},null);Y.Assert.isFalse(a)},"valuesAreEqual() should return true for comparing the same model":function(){var c=Kevlar.Model.extend({attributes:["id"]});var d=new c({id:1}),b=new c({id:1});var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for two different models":function(){var c=Kevlar.Model.extend({attributes:["id"]});var d=new c({id:1}),b=new c({id:2});var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isFalse(a)}},{name:"Test beforeSet()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr1","attr2"]});this.attribute=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:this.Model})},_should:{error:{"beforeSet() should throw an error if the string 'modelClass' config does not reference a Model class":"The string value 'modelClass' config did not resolve to a Model class for attribute 'attr'","beforeSet() should throw an error if the function value 'modelClass' config does not reference a Model class":"The function value 'modelClass' config did not resolve to a Model class for attribute 'attr'"}},"beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Kevlar.Model),c=new Kevlar.attribute.ModelAttribute({name:"attr"}),b,d;d=c.beforeSet(a,b,0);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,1);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,"");Y.Assert.areSame(null,d);d=c.beforeSet(a,b,"hi");Y.Assert.areSame(null,d);d=c.beforeSet(a,b,false);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,true);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,undefined);Y.Assert.areSame(null,d);d=c.beforeSet(a,b,null);Y.Assert.areSame(null,d)},"beforeSet() should throw an error if the string 'modelClass' config does not reference a Model class":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:"somethingThatIsNotDefined"});var e={attr1:1,attr2:2},d=c.beforeSet(a,b,e);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should throw an error if the function value 'modelClass' config does not reference a Model class":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:function(){return}});var e={attr1:1,attr2:2},d=c.beforeSet(a,b,e);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a direct reference to the Model subclass":function(){var a=JsMockito.mock(Kevlar.Model),d={attr1:1,attr2:2},b,c=this.attribute.beforeSet(a,b,d);Y.Assert.isInstanceOf(this.Model,c,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,c.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,c.get("attr2"),"The data should have been set to the new model")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a string":function(){window.__Kevlar_CollectionAttributeTest={};window.__Kevlar_CollectionAttributeTest.ns1={};window.__Kevlar_CollectionAttributeTest.ns1.ns2={};window.__Kevlar_CollectionAttributeTest.ns1.ns2.MyModel=Kevlar.Model.extend({attributes:["attr1","attr2"]});var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:"__Kevlar_CollectionAttributeTest.ns1.ns2.MyModel"});var e={attr1:1,attr2:2};var d=c.beforeSet(a,b,e);Y.Assert.isInstanceOf(window.__Kevlar_CollectionAttributeTest.ns1.ns2.MyModel,d,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,d.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,d.get("attr2"),"The data should have been set to the new model")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a function":function(){var c=Kevlar.Model.extend({attributes:["attr1","attr2"]});var a=JsMockito.mock(Kevlar.Model),b;var d=new Kevlar.attribute.ModelAttribute({name:"attr",modelClass:function(){return c}});var f={attr1:1,attr2:2};var e=d.beforeSet(a,b,f);Y.Assert.isInstanceOf(c,e,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,e.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,e.get("attr2"),"The data should have been set to the new model")},"beforeSet() should return an actual Model instance unchanged":function(){var a=JsMockito.mock(Kevlar.Model),b,d=new this.Model({attr1:1,attr2:2}),c=this.attribute.beforeSet(a,b,d);Y.Assert.areSame(d,c,"The return value from beforeSet should have been the same model instance");Y.Assert.areSame(1,c.get("attr1"),"The data should remain set to the new model");Y.Assert.areSame(2,c.get("attr2"),"The data should remain set to the new model")},"if no modelClass was provided, beforeSet() should return an anonymous data object unchanged":function(){var a=JsMockito.mock(Kevlar.Model),b;var c=new Kevlar.attribute.ModelAttribute({name:"attr"});var e={attr1:1,attr2:2};var d=c.beforeSet(a,b,e);Y.Assert.areSame(e,d)}},{name:"Test afterSet()","afterSet() should return the model (i.e. it doesn't forget the return statement!)":function(){var a=JsMockito.mock(Kevlar.Model);var b=new Kevlar.attribute.ModelAttribute({name:"attr"});var c=b.afterSet(a,a);Y.Assert.areSame(a,c)}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Kevlar.attribute.ObjectAttribute",items:[{name:"Test the defaultValue","The default defaultValue for ObjectAttribute should be null":function(){Y.Assert.isNull(Kevlar.attribute.ObjectAttribute.prototype.defaultValue)}},{name:"Test beforeSet()","beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Kevlar.Model),b=new Kevlar.attribute.ObjectAttribute({name:"attr"}),c;c=b.beforeSet(a,null,0);Y.Assert.areSame(null,c);c=b.beforeSet(a,null,1);Y.Assert.areSame(null,c);c=b.beforeSet(a,null,"");Y.Assert.areSame(null,c);c=b.beforeSet(a,null,"hi");Y.Assert.areSame(null,c);c=b.beforeSet(a,null,false);Y.Assert.areSame(null,c);c=b.beforeSet(a,null,true);Y.Assert.areSame(null,c);c=b.beforeSet(a,null,undefined);Y.Assert.areSame(null,c);c=b.beforeSet(a,null,null);Y.Assert.areSame(null,c)},"beforeSet() should return an object unchanged":function(){var a=JsMockito.mock(Kevlar.Model),b=new Kevlar.attribute.ObjectAttribute({name:"attr"});var d={attr1:1,attr2:2};var c=b.beforeSet(a,null,d);Y.Assert.areSame(d,c)}}]}));tests.unit.add(new Ext.test.TestSuite({name:"Kevlar.Collection",items:[{name:"Test the constructor",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"The constructor should accept a configuration object to initialize the Collection with an initial set of models and any other custom configs":function(){var a=new this.Model({attr:"value1"});var b=new this.Collection({models:a,customConfig:1});var c=b.getModels();Y.Assert.areSame(1,c.length,"There should now be one model in the collection");Y.Assert.areSame(a,c[0],"The model in the collection should be the one provided to the 'models' config");Y.Assert.areSame(1,b.customConfig,"The customConfig should have been applied to the collection")},"The constructor should accept an array of Models to initialize the Collection with":function(){var d=new this.Model({attr:"value1"}),b=new this.Model({attr:"value2"}),a=new this.Collection([d,b]);var c=a.getModels();Y.Assert.areSame(2,c.length,"There should now be two models in the collection");Y.Assert.areSame(d,c[0],"The first model should be the first model provided to the constructor");Y.Assert.areSame(b,c[1],"The second model should be the second model provided to the constructor")}},{name:"Test createModel()","createModel() should take an anonymous config object, and transform it into a Model instance, based on the 'model' config":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var b=Kevlar.Collection.extend({model:d});var c=new b();var a=c.createModel({attr:"testValue"});Y.Assert.isInstanceOf(d,a);Y.Assert.areSame("testValue",a.get("attr"))}},{name:"Test add()","add() should simply delegate to the insert() method":function(){var f=Kevlar.Model.extend({attributes:["attr"]});var c,b;var a=Kevlar.Collection.extend({model:f,insert:function(i,h){c=i;b=h}});var e=new a(),g=new f(),d=new f();e.add([g,d]);Y.ArrayAssert.itemsAreSame([g,d],c,"The models passed to insert() should be the same ones provided to add()");Y.Assert.isUndefined(b,"The index for the insert should be undefined, which defaults to appending the models to the collection")}},{name:"Test insert()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"insert() should be able to add a single Model instance to the Collection":function(){var b=new this.Collection(),a=new this.Model({attr:"value"}),c;c=b.getModels();Y.Assert.areSame(0,c.length,"Initial condition: There should be no models in the collection");b.insert(a);c=b.getModels();Y.Assert.areSame(1,c.length,"There should now be one model in the collection");Y.Assert.areSame(a,c[0],"The model added should be the first model in the collection")},"insert() should be able to add a single Model instance to the Collection at a specified index":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c]),d;d=b.getModels();Y.Assert.areSame(2,d.length,"Initial condition: There should be 2 models in the collection");b.insert(a,1);d=b.getModels();Y.Assert.areSame(3,d.length,"There should now be 3 models in the collection");Y.ArrayAssert.itemsAreSame([e,a,c],d,"model3 should have been added in the middle")},"insert() should be able to add an array of Model instances to the Collection":function(){var b=new this.Collection(),d=new this.Model({attr:"value1"}),a=new this.Model({attr:"value2"}),c;c=b.getModels();Y.Assert.areSame(0,c.length,"Initial condition: There should be no models in the collection");b.insert([d,a]);c=b.getModels();Y.Assert.areSame(2,c.length,"There should now be two models in the collection");Y.Assert.areSame(d,c[0],"The first model added in the array should be the first model in the collection");Y.Assert.areSame(a,c[1],"The second model added in the array should be the second model in the collection")},"insert() should be able to add an array of Model instance to the Collection at a specified index":function(){var f=new this.Model({attr:"value1"}),d=new this.Model({attr:"value2"}),b=new this.Model({attr:"value3"}),a=new this.Model({attr:"value4"}),c=new this.Collection([f,d]),e;e=c.getModels();Y.Assert.areSame(2,e.length,"Initial condition: There should be 2 models in the collection");c.insert([b,a],1);e=c.getModels();Y.Assert.areSame(4,e.length,"There should now be 4 models in the collection");Y.ArrayAssert.itemsAreSame([f,b,a,d],e,"model3 and model4 should have been added in the middle")},"insert() should fire the 'add' event with the array of inserted models, even if only one model is inserted":function(){var c=new this.Collection(),a=new this.Model({attr:"value"}),d;var b;c.on("add",function(e,f){b=f});c.insert(a);Y.Assert.areSame(1,b.length,"1 model should have been provided to the 'add' event");Y.Assert.areSame(a,b[0],"The model provided with the 'add' event should be the model added to the collection")},"insert() should fire the 'add' event with the array of inserted models when multiple models are inserted":function(){var c=new this.Collection(),e=new this.Model({attr:"value1"}),b=new this.Model({attr:"value2"}),d;var a;c.on("add",function(f,g){a=g});c.insert([e,b]);Y.Assert.areSame(2,a.length,"2 models should have been provided to the 'add' event");Y.Assert.areSame(e,a[0],"The first model added in the array should be the first model added to the collection");Y.Assert.areSame(b,a[1],"The second model added in the array should be the second model added to the collection")},"insert() should *not* fire the 'add' event for a model that is already in the Collection":function(){var a=new this.Model({attr:"value1"}),c=new this.Collection([a]);var b=false;c.on("add",function(d,e){b=true});c.insert(a);Y.Assert.isFalse(b,"The 'add' event should not have been fired for another insert of the same model")},"insert() should *not* fire the 'add' event for a model that is already in the Collection when multiple models are inserted, and only some exist already":function(){var d=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),b=new this.Collection([d]);var a;b.on("add",function(e,f){a=f});b.insert([d,c]);Y.ArrayAssert.itemsAreSame([c],a,"The 'add' event should have only fired with the model that was actually added")},"insert() should reorder models when they already exist in the Collection":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c,a]),d;b.insert(a,0);Y.ArrayAssert.itemsAreSame([a,e,c],b.getModels(),"insert() should have moved model3 to the beginning");b.insert([c,e],0);Y.ArrayAssert.itemsAreSame([c,e,a],b.getModels(),"insert() should have moved model2 and model1 to the beginning");b.insert(c,2);Y.ArrayAssert.itemsAreSame([e,a,c],b.getModels(),"insert() should have moved model2 to the end");b.insert(c,-1000);Y.ArrayAssert.itemsAreSame([c,e,a],b.getModels(),"insert() should have moved model2 to the beginning with an out of bounds negative index");b.insert([e,c],1000);Y.ArrayAssert.itemsAreSame([a,e,c],b.getModels(),"insert() should have moved model1 and model2 to the end with an out of bounds positive index")},"insert() should fire the 'reorder' event when reordering models":function(){var h=new this.Model({attr:"value1"}),g=new this.Model({attr:"value2"}),f=new this.Model({attr:"value3"}),b=new this.Collection([h,g,f]),a;var i=0,c=[],e=[],d=[];b.on("reorder",function(l,j,k,m){i++;c.push(j);e.push(k);d.push(m)});b.insert(f,0);Y.ArrayAssert.itemsAreSame([f,h,g],b.getModels(),"The models should be in the correct new order (this is mostly here to just show which order the collection should now be in)");Y.Assert.areSame(1,i,"The reorder event should have been fired exactly once");Y.ArrayAssert.itemsAreSame([f],c,"model3 should have been fired with a 'reorder' event (and that is the only reorder event that should have been fired)");Y.ArrayAssert.itemsAreSame([0],e,"the new index for model3 should have been reported as index 0");Y.ArrayAssert.itemsAreSame([2],d,"the old index for model3 should have been reported as index 2");i=0;c=[];e=[];d=[];b.insert([h,g],0);Y.ArrayAssert.itemsAreSame([h,g,f],b.getModels(),"The models should be in the correct new order (this is mostly here to just show which order the collection should now be in)");Y.Assert.areSame(2,i,"The reorder event should have been fired exactly twice");Y.ArrayAssert.itemsAreSame([h,g],c,"model1 and model2 should have been fired with a 'reorder' events");Y.ArrayAssert.itemsAreSame([0,1],e,"the new indexes for model1 and model2 should have been reported as index 0, and 1, respectively");Y.ArrayAssert.itemsAreSame([1,2],d,"the old indexes for model1 and model2 should have been reported as index 1, and 2, respectively")},"insert() should *not* reorder models when calling insert() without the `index` argument (which would be the case as well if add() was called)":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c,a]),d;b.insert(e);Y.ArrayAssert.itemsAreSame([e,c,a],b.getModels(),"The models should be in the original order, as the supposed 'append' should not have happened because the model was already in the collection, and no new index was given")},"insert() should transform anonymous data objects to Model instances, based on the 'model' config":function(){var c=new this.Collection(),b={attr:"value1"},a={attr:"value2"},d;d=c.getModels();Y.Assert.areSame(0,d.length,"Initial condition: There should be no models in the collection");c.insert([b,a]);d=c.getModels();Y.Assert.areSame(2,d.length,"There should now be two models in the collection");Y.Assert.areSame("value1",d[0].get("attr"),"The first model added in the array should have the data provided from modelData1");Y.Assert.areSame("value2",d[1].get("attr"),"The second model added in the array should have the data provided from modelData2")},"insert() should fire the 'add' event with instantiated models for any anonymous config objects":function(){var d=new this.Collection(),c={attr:"value1"},b={attr:"value2"};var a;d.on("add",function(e,f){a=f});d.insert([c,b]);Y.Assert.areSame(2,a.length,"2 models should have been provided to the 'add' event");Y.Assert.areSame("value1",a[0].get("attr"),"The first model added in the array should have the data provided from modelData1");Y.Assert.areSame("value2",a[1].get("attr"),"The second model added in the array should have the data provided from modelData2")},"insert() should insert models in the order specified by the sortBy config, if one is provided":function(){var f=Kevlar.Model.extend({attributes:["name"]});var a=Kevlar.Collection.extend({sortBy:function(l,k){var j=l.get("name"),i=k.get("name");return(j<i)?-1:(j>i)?1:0}});var h=new f({name:"A"}),e=new f({name:"B"}),b=new f({name:"D"}),g;var d=new a();d.insert([e,b,h]);g=d.getModels();Y.ArrayAssert.itemsAreSame([h,e,b],g,"The models should have been re-ordered based on the 'name' attribute");var c=new f({name:"C"});d.insert(c);g=d.getModels();Y.ArrayAssert.itemsAreSame([h,e,c,b],g,"The models should have been re-ordered based on the 'name' attribute with the new model")},"the sortBy() function should be called in the scope of the Collection":function(){var a="";var f=Kevlar.Model.extend({attributes:["name"]});var b=Kevlar.Collection.extend({getAttributeNameToSortBy:function(){return"name"},sortBy:function(i,h){a=this.getAttributeNameToSortBy();return 0}});var g=new f({name:"A"}),e=new f({name:"B"}),c=new f({name:"C"});var d=new b();d.insert([e,c,g]);Y.Assert.areSame("name",a,"The attributeNameToSortBy variable should have been set by sortBy() being called in the correct scope, able to access its helper method")},"insert() should not allow duplicate models (at this time. config option to come)":function(){var a=new this.Model(),b=new this.Collection();b.insert([a,a]);Y.ArrayAssert.itemsAreSame([a],b.getModels(),"There should only be the one model in the collection at this time")},"insert() should attach a 'change' listener for changes to the 'idAttribute' of a model, so that its internal modelsById hashmap can be updated if it changes":function(){var d=0,g,a;var f=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=Kevlar.Collection.extend({onModelIdChange:function(i,j,h){d++;g=j;a=h;this._super(arguments)}});var b=new f();var e=new c([b]);b.set("id",1);Y.Assert.areSame(1,d,"The onModelIdChange method should have been called exactly once");Y.Assert.areSame(1,g,"The newIdValue should be 1");Y.Assert.isUndefined(a,"The oldIdValue should be undefined");Y.Assert.areSame(b,e.getById(1),"The model should have been able to be retrieved by its ID");b.set("id",2);Y.Assert.areSame(2,d,"The onModelIdChange method should have been called exactly twice at this point");Y.Assert.areSame(2,g,"The newIdValue should be 2");Y.Assert.areSame(1,a,"The oldIdValue should be 1");Y.Assert.isNull(e.getById(1),"The model should no longer be retrievable by its old ID");Y.Assert.areSame(b,e.getById(2),"The model should now be retrievable by its new ID")}},{name:"Test remove()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"remove() should be able to remove a single Model from the Collection":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),b=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"}),a=new this.Model({boolAttr:true,numberAttr:3,stringAttr:"value3"});var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.remove(d);e=c.getModels();Y.ArrayAssert.doesNotContain(d,e,"model2 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([f,b,a],e,"The remaining 3 models should all exist, and be in the correct order");c.remove(a);e=c.getModels();Y.ArrayAssert.doesNotContain(a,e,"model4 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([f,b],e,"The remaining 2 models should all exist, and be in the correct order");c.remove(f);e=c.getModels();Y.ArrayAssert.doesNotContain(f,e,"model1 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([b],e,"The remaining model should exist");c.remove(b);e=c.getModels();Y.ArrayAssert.isEmpty(e,"There should be no more models left")},"remove() should be able to remove an array of Models from the Collection":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),b=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"}),a=new this.Model({boolAttr:true,numberAttr:3,stringAttr:"value3"});var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.remove([d,a]);e=c.getModels();Y.ArrayAssert.itemsAreSame([f,b],e,"Only model1 and model3 should remain")},"remove() should fire the 'remove' event with the array of removed models, even if only one model has been removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d,c]);var a;b.on("remove",function(e,f){a=f});b.remove(c);Y.ArrayAssert.itemsAreSame([c],a)},"remove() should fire the 'remove' event with the array of removed models when multiple models are removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d,c]);var a;b.on("remove",function(e,f){a=f});b.remove([d,c]);Y.ArrayAssert.itemsAreSame([d,c],a)},"remove() should *not* fire the 'remove' event if no models are actually removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d]);var a=0;b.on("remove",function(e,f){a++});b.remove(c);Y.Assert.areSame(0,a)},"remove() should remove the model from the modelsById hashmap, so it is no longer retrievable by getById":function(){var c=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var a=new c({id:1});var b=new Kevlar.Collection([a]);Y.Assert.areSame(a,b.getById(1),"Initial condition: the model should be available to getById()");b.remove(a);Y.Assert.isNull(b.getById(1),"The model should no longer be retrievable by getById() after removal")},"remove() should remove the model from the modelsByClientId hashmap, so it is no longer retrievable by getById":function(){var d=Kevlar.Model.extend({}),a=new d(),b=a.getClientId(),c=new Kevlar.Collection([a]);Y.Assert.areSame(a,c.getByClientId(b),"Initial condition: the model should be available to getByClientId()");c.remove(a);Y.Assert.isNull(c.getByClientId(b),"The model should no longer be retrievable by getByClientId() after removal")},"remove() should remove the 'change' listener for changes to the 'idAttribute' of a model, so that its internal modelsById hashmap can be updated if it changes":function(){var d=0,g,a;var f=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=Kevlar.Collection.extend({onModelIdChange:function(i,j,h){d++;g=j;a=h;this._super(arguments)}});var b=new f();var e=new c([b]);b.set("id",1);Y.Assert.areSame(1,d,"The onModelIdChange method should have been called exactly once");Y.Assert.areSame(1,g,"The newIdValue should be 1");Y.Assert.isUndefined(a,"The oldIdValue should be undefined");Y.Assert.areSame(b,e.getById(1),"The model should have been able to be retrieved by its ID");e.remove(b);b.set("id",2);Y.Assert.areSame(1,d,"The onModelIdChange method should *not* have been called again at this point")}},{name:"Test removeAll()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});this.Collection=Kevlar.Collection.extend({model:this.Model})},"removeAll() should be able to remove all Models from the Collection":function(){var f=new this.Model(),d=new this.Model(),b=new this.Model(),a=new this.Model();var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.removeAll();e=c.getModels();Y.ArrayAssert.isEmpty(e,"There should be no models left in the collection")},"removeAll() should fire the 'remove' event with the array of removed models when multiple models are removed":function(){var f=new this.Model(),e=new this.Model(),c=new this.Model(),b=new this.Model();var d=new this.Collection([f,e,c,b]);var a;d.on("remove",function(g,h){a=h});d.removeAll();Y.ArrayAssert.itemsAreSame([f,e,c,b],a)},"removeAll() should *not* fire the 'remove' event if no models are actually removed":function(){var b=new this.Collection();var a=0;b.on("remove",function(c,d){a++});b.removeAll();Y.Assert.areSame(0,a)},"removeAll() should clear the `modelsByClientId` and `modelsById` hashmaps":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getByClientId(c.getClientId()),"Initial condition: should be able to retrieve model1 by clientId");Y.Assert.areSame(c,a.getById(c.getId()),"Initial condition: should be able to retrieve model1 by id");Y.Assert.areSame(b,a.getByClientId(b.getClientId()),"Initial condition: should be able to retrieve model2 by clientId");Y.Assert.areSame(b,a.getById(b.getId()),"Initial condition: should be able to retrieve model2 by id");a.removeAll();Y.Assert.isNull(a.getByClientId(c.getClientId()),"should no longer be able to retrieve model1 by clientId");Y.Assert.isNull(a.getById(c.getId()),"should no longer be able to retrieve model1 by id");Y.Assert.isNull(a.getByClientId(b.getClientId()),"should no longer be able to retrieve model2 by clientId");Y.Assert.isNull(a.getById(b.getId()),"should no longer be able to retrieve model2 by id")}},{name:"Test getAt()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});this.Collection=Kevlar.Collection.extend({model:this.Model})},"getAt() should return the model at a given index":function(){var c=new this.Model(),b=new this.Model();var a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getAt(0),"model1 should be at index 0");Y.Assert.areSame(b,a.getAt(1),"model2 should be at index 1")},"getAt() should return null for an index that is out of bounds":function(){var c=new this.Model(),b=new this.Model();var a=new this.Collection([c,b]);Y.Assert.isNull(a.getAt(-1),"Should be null for a negative index");Y.Assert.isNull(a.getAt(2),"Should be null for an index greater than the number of models")}},{name:"Test getFirst()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"getFirst() should retrieve the first Model in the Collection":function(){var c=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getFirst())},"getFirst() should return null if there are no models in the Collection":function(){var a=new this.Collection();Y.Assert.isNull(a.getFirst())}},{name:"Test getLast()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"getLast() should retrieve the first Model in the Collection":function(){var c=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Collection([c,b]);Y.Assert.areSame(b,a.getLast())},"getLast() should return null if there are no models in the Collection":function(){var a=new this.Collection();Y.Assert.isNull(a.getLast())}},{name:"Test getRange()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["attr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"getRange() should retrieve all models when no arguments are provided":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d=b.getRange();Y.ArrayAssert.itemsAreSame([e,c,a],d)},"getRange() should retrieve models based on just the startIndex argument, defaulting endIndex to the last model in the Collection":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d;d=b.getRange(0);Y.ArrayAssert.itemsAreSame([e,c,a],d,"All models should have been retrieved");d=b.getRange(1);Y.ArrayAssert.itemsAreSame([c,a],d,"The second and third models should have been retrieved");d=b.getRange(2);Y.ArrayAssert.itemsAreSame([a],d,"The third model should have been retrieved");d=b.getRange(3);Y.ArrayAssert.isEmpty(d,"No models should have been retrieved")},"getRange() should retrieve models based on the startIndex and endIndex arguments":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d;d=b.getRange(0,0);Y.ArrayAssert.itemsAreSame([e],d,"0, 0 args did not work correctly. First model should have been retrieved");d=b.getRange(0,1);Y.ArrayAssert.itemsAreSame([e,c],d,"0, 1 args did not work correctly. First and second model should have been retrieved");d=b.getRange(1,1);Y.ArrayAssert.itemsAreSame([c],d,"1, 1 args did not work correctly. Second model should have been retrieved");d=b.getRange(1,2);Y.ArrayAssert.itemsAreSame([c,a],d,"1, 2 args did not work correctly. Second and third models should have been retrieved");d=b.getRange(0,2);Y.ArrayAssert.itemsAreSame([e,c,a],d,"0, 2 args did not work correctly. Second and third models should have been retrieved");d=b.getRange(-10000,10000);Y.ArrayAssert.itemsAreSame([e,c,a],d,"Out of range -10000, 10000 args did not work correctly. All models should have been retrieved")}},{name:"Test getModels()","getModels() should return the array of models, but in a new array so that the array can be changed":function(){var e=Kevlar.Model.extend({attributes:["attr"]}),f=new e({attr:1}),d=new e({attr:2}),b=new e({attr:3}),c=new Kevlar.Collection([f,d,b]);var a=c.getModels();a.splice(0,1);Y.Assert.areSame(2,a.length,"The models array should have been reduced to 2 elements");Y.Assert.areSame(3,c.getCount(),"The number of models in the collection should still be 3")}},{name:"Test getData()",setUp:function(){this.origNativeObjectConverter=Kevlar.data.NativeObjectConverter;var a=this.args={};Kevlar.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Kevlar.data.NativeObjectConverter=this.origNativeObjectConverter},"getData() should delegate to the singleton NativeObjectConverter to create an Array representation of its data":function(){var e=Kevlar.Model.extend({attributes:["attr1","attr2"]});var c=Kevlar.Collection.extend({model:e});var d=new c([{attr1:"value1",attr2:"value2"}]);var b={raw:true};var a=d.getData(b);Y.Assert.areSame(d,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the collection.");Y.Assert.areSame(b,this.args[1],"The second arg provided to NativeObjectConverter::convert() should have been the options object")}},{name:"Test getCount()","getCount() should return 0 for a brand new Collection":function(){var a=new Kevlar.Collection();Y.Assert.areSame(0,a.getCount())},"getCount() should return the number of models inserted at any given time":function(){var d=Kevlar.Model.extend({attributes:["attr"]}),e=new d({attr:1}),c=new d({attr:2}),a=new d({attr:3}),b=new Kevlar.Collection([e,c]);Y.Assert.areSame(2,b.getCount(),"initially, the collection should have 2 models");b.remove(e);Y.Assert.areSame(1,b.getCount(),"After removal of model1, the collection should have 1 model");b.add([e,a]);Y.Assert.areSame(3,b.getCount(),"After adding model1 and model3, the collection should have 3 models")}},{name:"Test getByClientId()","getByClientId() should retrieve a model by its clientId":function(){var c=Kevlar.Model.extend({}),d=new c(),b=new c();var a=new Kevlar.Collection([d,b]);Y.Assert.areSame(d,a.getByClientId(d.getClientId()),"model1 should have been able to be retrieved by its clientId");Y.Assert.areSame(b,a.getByClientId(b.getClientId()),"model2 should have been able to be retrieved by its clientId")},"getByClientId() should return null if the collection doesn't have the model whose clientId is requested":function(){var c=Kevlar.Model.extend({}),a=new c();var b=new Kevlar.Collection();Y.Assert.isNull(b.getByClientId(a.getClientId()))}},{name:"Test getById()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"})},"getById() should retrieve a model by its id attribute":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new Kevlar.Collection([c,b]);Y.Assert.areSame(c,a.getById(1),"model1 should have been able to be retrieved by its id");Y.Assert.areSame(b,a.getById(2),"model2 should have been able to be retrieved by its id")},"getById() should return null for a model id that doesn't exist within its collection":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new Kevlar.Collection();Y.Assert.isNull(a.getById(1),"Test with no models in the collection at all");a.add(c);Y.Assert.isNull(a.getById(2),"Test with a model in the collection");Y.Assert.areSame(c,a.getById(1),"Sanity check, model1 should be able to be retrieved by its id at this point")},"getById() should retreive a model by its id attribute, even if it doesn't yet have an id when it is added to the collection (the id is added later)":function(){var a=new this.Model(),b=new Kevlar.Collection([a]);a.set("id",1);Y.Assert.areSame(a,b.getById(1))}},{name:"Test has()","has() should return true if a model has been added to the collection, and false if a model has not been added to the collection":function(){var c=Kevlar.Model.extend({attributes:["attr"]});var d=new c(),b=new c(),a=new Kevlar.Collection();Y.Assert.isFalse(a.has(d),"Initial condition: the collection should not have model1");Y.Assert.isFalse(a.has(b),"Initial condition: the collection should not have model2");a.add(d);Y.Assert.isTrue(a.has(d),"The collection should now have model1");Y.Assert.isFalse(a.has(b),"The collection should still not have model2, as it has not been added");a.remove(d);Y.Assert.isFalse(a.has(d),"The collection should not have model1 anymore, as it has been removed")}},{name:"Test indexOf()","indexOf() should return the index of a model in the collection":function(){var c=Kevlar.Model.extend({attributes:["attr"]}),d=new c(),b=new c(),a=new Kevlar.Collection([d,b]);Y.Assert.areSame(0,a.indexOf(d),"model1 should be at index 0");Y.Assert.areSame(1,a.indexOf(b),"model2 should be at index 1")},"indexOf() should return -1 for a model that does not exist within the collection":function(){var c=Kevlar.Model.extend({attributes:["attr"]}),d=new c(),b=new c(),a=new Kevlar.Collection([d]);Y.Assert.areSame(-1,a.indexOf(b),"model2 is not in the collection, so indexOf() should return -1")}},{name:"Test indexOfId()","indexOfId() should return the index of a model by its id in the collection":function(){var c=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"}),d=new c({id:1}),b=new c({id:2}),a=new Kevlar.Collection([d,b]);Y.Assert.areSame(0,a.indexOfId(1),"model1 should be at index 0");Y.Assert.areSame(1,a.indexOfId(2),"model2 should be at index 1")},"indexOfId() should return -1 for a model by its id that does not exist within the collection":function(){var c=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"}),d=new c({id:1}),b=new c({id:2}),a=new Kevlar.Collection([d]);Y.Assert.areSame(-1,a.indexOfId(2),"model2 is not in the collection, so indexOfId() should return -1")}},{name:"Test find()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"find() should find a Model by attribute and value":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var a=new this.Collection([d,b]),c;c=a.find("boolAttr",false);Y.Assert.areSame(d,c,"did not find model by boolean false");c=a.find("boolAttr",true);Y.Assert.areSame(b,c,"did not find model by boolean true");c=a.find("numberAttr",0);Y.Assert.areSame(d,c,"did not find model by number 0");c=a.find("numberAttr",1);Y.Assert.areSame(b,c,"did not find model by number 1");c=a.find("stringAttr","");Y.Assert.areSame(d,c,"did not find model by empty string");c=a.find("stringAttr","value");Y.Assert.areSame(b,c,"did not find model by string value");c=a.find("stringAttr","ooglyBoogly");Y.Assert.isNull(c,"Finding a model by an attribute that doesn't exist should return null")},"find() should start at a given startIndex when provided":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.find("boolAttr",false,{startIndex:1});Y.Assert.areSame(a,d,"The model that was found should have been model3, because it is the only one that matched the criteria past the given startIndex")}},{name:"Test findBy()",setUp:function(){this.Model=Kevlar.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Kevlar.Collection.extend({model:this.Model})},"findBy should accept a function that when it returns true, it considers the Model the match":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){if(g.get("boolAttr")===true){return true}});Y.Assert.areSame(c,d)},"findBy should return null when there is no match":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){});Y.Assert.isNull(d)},"findBy should start at the given startIndex":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){if(g.get("boolAttr")===false){return true}},{startIndex:1});Y.Assert.areSame(a,d)}}]}));tests.unit.data.add(new Ext.test.TestSuite({name:"Kevlar.data.NativeObjectConverter",items:[{name:"Test convert() with a model","convert() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=Kevlar.data.NativeObjectConverter.convert(a);Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"convert() should return the data by running attributes' `get` functions (not just returning the raw data), when the `raw` option is not provided":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=Kevlar.data.NativeObjectConverter.convert(a);Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"when the `raw` option is provided as true, convert() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},{name:"attribute3",raw:function(e,d){return e+" "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2",attribute3:"value3"});var b=Kevlar.data.NativeObjectConverter.convert(a,{raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned")},"convert() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=Kevlar.data.NativeObjectConverter.convert(a,{persistedOnly:true});Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")},"convert() should only process the attributes of a Model that are defined by the 'attributeNames' option (if provided)":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=Kevlar.data.NativeObjectConverter.convert(a,{attributeNames:["attribute1","attribute3"]});Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The data should only have 'attribute1' and 'attribute3'")},"Using the 'attributeNames' option should only affect the Model that is provided to convert(), not nested models":function(){var d=Kevlar.Model.extend({attributes:["attribute1","attribute2"]});var a=new d({attribute1:new d({attribute1:"innerValue1",attribute2:"innerValue2"}),attribute2:"value2"});var c=Kevlar.data.NativeObjectConverter.convert(a,{attributeNames:["attribute1"]});Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The data should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],c,"attribute1 should exist on the return data");var b=c.attribute1;Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The inner (nested) data should have 2 properties");Y.Assert.areSame("innerValue1",b.attribute1,"The inner (nested) attribute1 should have the correct value");Y.Assert.areSame("innerValue2",b.attribute2,"The inner (nested) attribute2 should have the correct value")},"convert() should deep convert nested models, while handing circular references":function(){var d=Kevlar.Model.extend({addAttributes:["value","relatedModel"]});var a=new d(),c=new d();a.set("value","outerModel-value");a.set("relatedModel",c);c.set("value","innerModel-value");c.set("relatedModel",a);var b=Kevlar.data.NativeObjectConverter.convert(a);Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The outerModel data should only have 2 properties");Y.Assert.areSame("innerModel-value",b.relatedModel.value,"Should be able to access the inner model's value from the outer model.");Y.Assert.areSame("outerModel-value",b.relatedModel.relatedModel.value,"Should be able to access the outer model's value from the inner model");Y.Assert.areSame("innerModel-value",b.relatedModel.relatedModel.relatedModel.value,"Should be able to go around and around, just to make sure we have the circular dependency handled");Y.Assert.areSame(b,b.relatedModel.relatedModel,"The outer -> inner -> outer should point to the `data` object returned by the convert() method, as that is the model that was converted");Y.Assert.areSame(b.relatedModel.relatedModel,b.relatedModel.relatedModel.relatedModel.relatedModel,"The outer -> inner -> outer should point to the outer reference")}},{name:"Test convert() with a Collection","convert() should convert a Collection of Models into an Array of Objects":function(){var d=Kevlar.Model.extend({attributes:["attr1","attr2"]});var a=Kevlar.Collection.extend({model:d});var c=new a([{attr1:1,attr2:2},{attr1:3,attr2:4}]);var b=Kevlar.data.NativeObjectConverter.convert(c);Y.Assert.isArray(b,"the data should be an array");Y.Assert.areSame(2,b.length,"There should be 2 items in the array");Y.Assert.areSame(1,b[0].attr1,"The first array item's attr1 should be 1");Y.Assert.areSame(2,b[0].attr2,"The first array item's attr2 should be 2");Y.Assert.areSame(3,b[1].attr1,"The second array item's attr1 should be 3");Y.Assert.areSame(4,b[1].attr2,"The second array item's attr2 should be 4")},"convert() should deep convert nested models/collections, while handing circular references":function(){var e=Kevlar.Model.extend({attributes:["nestedCollection"]});var b=Kevlar.Collection.extend({model:e});var a=new e();var d=new b();a.set("nestedCollection",d);d.add(a);var c=Kevlar.data.NativeObjectConverter.convert(d);Y.Assert.isArray(c,"the data should be an array");Y.Assert.areSame(1,c.length,"There should be 1 item in the array");Y.Assert.isObject(c[0],"The data's first element should be an object");Y.Assert.isArray(c[0].nestedCollection,"The data's first element's nestedCollection should be an array");Y.Assert.areSame(c,c[0].nestedCollection,"The nested collection's array should refer back to the same array created for 'data'");Y.Assert.areSame(c,c[0].nestedCollection[0].nestedCollection[0].nestedCollection,"Nesty nesty nesty should work")}}]}));tests.unit.add(new Ext.test.TestCase({name:"Kevlar.ModelCache",setUp:function(){this.MockModel1=function(){};this.MockModel1.__Kevlar_modelTypeId=1;this.MockModel2=function(){};this.MockModel2.__Kevlar_modelTypeId=2;Kevlar.ModelCache.models={}},tearDown:function(){Kevlar.ModelCache.models={}},"get() should return a reference to the same model provided to it if not providing an id":function(){var b=new this.MockModel1();var a=Kevlar.ModelCache.get(b);Y.Assert.areSame(b,a)},"get() should *not* return a reference to the first model, when a second one is passed in with the same type (subclass), but not passing in any id's":function(){var d=new this.MockModel1(),b=new this.MockModel1();var a=Kevlar.ModelCache.get(d);var c=Kevlar.ModelCache.get(b);Y.Assert.areNotSame(a,c)},"get() should return a reference to the first model, when a second one is passed with the same id":function(){var d=new this.MockModel1();var b=new this.MockModel1();var a=Kevlar.ModelCache.get(d,1);var c=Kevlar.ModelCache.get(b,1);Y.Assert.areSame(a,c)},"get() should *not* return a reference to the first model, when a second one is passed with the same id, but of a different model type (subclass)":function(){var d=new this.MockModel1(),b=new this.MockModel2();var a=Kevlar.ModelCache.get(d,1);var c=Kevlar.ModelCache.get(b,1);Y.Assert.areNotSame(a,c)},"get() should *not* return a reference to the first model, when a second one is passed with the same type (subclass), but with a different id":function(){var d=new this.MockModel1(),b=new this.MockModel1();var a=Kevlar.ModelCache.get(d,1);var c=Kevlar.ModelCache.get(b,2);Y.Assert.areNotSame(a,c)}}));tests.unit.add(new Ext.test.TestSuite({name:"Kevlar.Model",items:[{name:"Test the onClassExtended static method","After extending model, the subclass should have a unique __Kevlar_modelTypeId property":function(){var a=Kevlar.Model.extend({});Y.Assert.isNumber(a.__Kevlar_modelTypeId,"The Model should now have a static __Kevlar_modelTypeId property that is a number")},"Attributes should inherit from a Model subclass's superclass when the subclass defines no attributes of its own":function(){var c=Kevlar.Model.extend({attributes:["field1"]});var b=c.extend({});var a=(new b()).attributes;Y.Assert.areSame(1,Kevlar.util.Object.length(a),"There should be exactly 1 attribute");Y.ObjectAssert.hasKey("field1",a,"field1 should exist as the attribute")},"Attributes should inherit from a Model subclass's superclass when the subclass does define attributes of its own":function(){var c=Kevlar.Model.extend({});var b=c.extend({addAttributes:["a","b"]});var a=(new b()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and its superclass as well (i.e. more than one level up)":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{addAttributes:["c","d","e"]});var a=(new c()).attributes;Y.Assert.areSame(5,Kevlar.util.Object.length(a),"There should be exactly 5 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and all of its superclasses (i.e. more than two levels up)":function(){var e=Kevlar.Model.extend({});var c=Kevlar.extend(e,{addAttributes:["a","b"]});var d=Kevlar.extend(c,{addAttributes:["c","d","e"]});var b=Kevlar.extend(d,{addAttributes:["f"]});var a=(new b()).attributes;Y.Assert.areSame(6,Kevlar.util.Object.length(a),"There should be exactly 6 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("f",a,"SubSubSubClassModel should have the 'f' attribute defined in its final 'attributes' hash.")},"Attribute definitions defined in a subclass should take precedence over attribute definitions in a superclass":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:[{name:"a",defaultValue:1}]});var c=Kevlar.extend(b,{addAttributes:[{name:"a",defaultValue:2},"b"]});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.Assert.areSame(2,a.a.defaultValue,"The attribute in the subclass should have overridden its superclass")},"A subclass that doesn't define any attributes should inherit all of them from its superclass(es)":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{addAttributes:["a","b"]});var c=Kevlar.extend(b,{});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"A superclass that doesn't define any attributes should be skipped for attributes, but the subclass should still inherit from superclasses above it":function(){var d=Kevlar.Model.extend({});var b=Kevlar.extend(d,{});var c=Kevlar.extend(b,{addAttributes:["a","b"]});var a=(new c()).attributes;Y.Assert.areSame(2,Kevlar.util.Object.length(a),"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"One should be able to use `attributes` in place of `addAttributes` on the prototype, if they wish":function(){var c=Kevlar.Model.extend({attributes:["a","b"]});var b=c.extend({attributes:["c"]});var a=(new b()).attributes;Y.Assert.areSame(3,Kevlar.util.Object.length(a),"There should be exactly 3 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.")}},{name:"Test Initialization (constructor)",ttype:"testsuite",items:[{name:"Test lazy instantiating a persistenceProxy",_should:{error:{"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":"Kevlar.persistence.Proxy.create(): No `type` property provided on persistenceProxy config object","Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":"Kevlar.persistence.Proxy.create(): Unknown Proxy type: 'nonexistentproxy'"}},"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{}});var a=new b()},"Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var a=new b()},"Providing a valid config object should instantiate the Proxy *on class's the prototype*":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new b();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,b.prototype.persistenceProxy)},"Providing a valid config object should instantiate the Proxy *on the correct subclass's prototype*, shadowing superclasses":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var c=Kevlar.extend(b,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new c();Y.Assert.isInstanceOf(Kevlar.persistence.RestProxy,c.prototype.persistenceProxy)}},{name:"Test change event upon initialization",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"The Model should fire its 'change' event when an attribute's data is set externally":function(){var b=false;var a=new this.TestModel();a.addListener("change",function(){b=true});a.set("attribute1","value1");Y.Assert.isTrue(b,"The change event should have been fired during the set of the new data")}},{name:"Test that the initial default values are applied",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"A attribute with a defaultValue but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"A attribute with a defaultValue that is a function, but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"A attribute with a defaultValue and also provided data should have its provided data when retrieved":function(){var a=new this.TestModel({attribute2:"attribute2's data"});Y.Assert.areSame("attribute2's data",a.get("attribute2"),"The 'default' specified on the Attribute should *not* have been applied, since it has a value.")}},{name:"Test initial data","Providing initial data to the constructor should not leave the model set as 'dirty' (i.e. it should have no 'changes')":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b({attribute1:"value1",attribute2:"value2"});Y.Assert.isFalse(a.isDirty(),"The model should not be dirty upon initialization");Y.Assert.isTrue(Kevlar.util.Object.isEmpty(a.getChanges),"There should not be any 'changes' upon initialization")}},{name:"Test that initialize() is called","The initialize() method should be called with the constructor function, for subclass initialization":function(){var b=false;var c=Kevlar.Model.extend({addAttributes:["test",{name:"test2",defaultValue:"defaultForTest2"}],initialize:function(){b=true}});var a=new c();Y.Assert.isTrue(b,"The initialize() method should have been called")}}]},{name:"Test getId()",_should:{error:{"getId() should throw an error if the default idAttribute 'id' does not exist on the model":"Error: The `idAttribute` (currently set to an attribute named 'id') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it.","getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":"Error: The `idAttribute` (currently set to an attribute named 'myIdAttribute') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it."}},"getId() should throw an error if the default idAttribute 'id' does not exist on the model":function(){var b=Kevlar.Model.extend({attributes:["field1","field2"]});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":function(){var b=Kevlar.Model.extend({attributes:["field1","field2"],idAttribute:"myIdAttribute"});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should return the value of the idAttribute":function(){var b=Kevlar.Model.extend({attributes:["myIdAttribute"],idAttribute:"myIdAttribute"});var a=new b({myIdAttribute:1});Y.Assert.areSame(1,a.getId())}},{name:"Test getIdAttribute()","getIdAttribute() should return the Kevlar.attribute.Attribute referenced by the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var a=new b();Y.Assert.isInstanceOf(Kevlar.attribute.Attribute,a.getIdAttribute())},"getIdAttribute() should return null if there is no attribute referenced by the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"ooglyBoogly"});var a=new b();Y.Assert.isNull(a.getIdAttribute())}},{name:"Test getIdAttributeName()","getIdAttributeName() should return the value of the 'idAttribute' config":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"myBrandyNewIdAttribute"});var a=new b();Y.Assert.areSame("myBrandyNewIdAttribute",a.getIdAttributeName())}},{name:"Test hasIdAttribute()","hasIdAttribute should return false when the idAttribute config does not reference a valid Attribute":function(){var b=Kevlar.Model.extend({attributes:["attr"],idAttribute:"id"});var a=new b();Y.Assert.isFalse(a.hasIdAttribute())},"hasIdAttribute should return truue when the idAttribute config does reference a valid Attribute":function(){var b=Kevlar.Model.extend({attributes:["id","attr"],idAttribute:"id"});var a=new b();Y.Assert.isTrue(a.hasIdAttribute())}},{name:"Test set()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},assertAttributeAcceptsAll:function(b,a){b.set(a,undefined);Y.Assert.isUndefined(b.get(a),a+"'s value should have the value set by set() (undefined).");b.set(a,null);Y.Assert.isNull(b.get(a),a+"'s value should have the value set by set() (null).");b.set(a,true);Y.Assert.isTrue(b.get(a),a+"'s value should have the value set by set() (true).");b.set(a,false);Y.Assert.isFalse(b.get(a),a+"'s value should have the value set by set() (false).");b.set(a,0);Y.Assert.areSame(0,b.get(a),a+"'s value should have the value set by set() (0).");b.set(a,1);Y.Assert.areSame(1,b.get(a),a+"'s value should have the value set by set() (1).");b.set(a,"");Y.Assert.areSame("",b.get(a),a+"'s value should have the value set by set() ('').");b.set(a,"Hello");Y.Assert.areSame("Hello",b.get(a),a+"'s value should have the value set by set() ('Hello').");b.set(a,{});Y.Assert.isObject(b.get(a),a+"'s value should have the value set by set() (object).");b.set(a,[]);Y.Assert.isArray(b.get(a),a+"'s value should have the value set by set() (array).")},"set() should accept all datatypes including falsy values":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute1")},"set() should accept all datatypes, and still work even with a default value":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute2")},"set() should accept all datatypes, and still work even with a given value":function(){var a=new this.TestModel({attribute2:"initial value"});this.assertAttributeAcceptsAll(a,"attribute2")},"After the successful set() of an attribute, the Model should be considered 'dirty'":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isTrue(a.isDirty(),"After a set, the model should now be considered 'dirty'")},"After a set() of an attribute to the same value from a clean state, the Model should NOT be considered 'dirty' (as the value didn't change)":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isFalse(a.isDirty(),"After a set to the *same value*, the model should not be considered 'dirty' (as the value didn't change)")},"set() should not re-set an attribute to the same value from the initial value provided to the constructor":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(0,c,"The attribute should not have been registered as 'changed' when providing the same value")},"set() should not re-set an attribute to the same value":function(){var c=0;var b=Kevlar.Model.extend({addAttributes:["attribute1"]});var a=new b();a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(1,c,"Initially, the attribute should have been changed exactly once.");a.set("attribute1","value1");Y.Assert.areSame(1,c,"The attribute should not have been registered as 'changed' the second time. Should still only have '1 change'.")},"set() should run the Attribute's set() method on an attribute that has initial data of its own":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute2val attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute1")},"set() should convert an attribute with a 'set' function when it is set() again":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});a.set("attribute2","newattribute2value");Y.Assert.areSame("newattribute2value attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute2")},"set() should delegate to the Attribute's beforeSet() and afterSet() methods to do any pre and post processing needed for the value":function(){var e,b;var a=Kevlar.attribute.Attribute.extend({beforeSet:function(g,f,h){return(e=h+1)},afterSet:function(f,g){return(b=g+20)}});var d=Kevlar.Model.extend({attributes:[new a({name:"attr1",set:function(f){return f+5}})]});var c=new d({attr1:0});Y.Assert.areSame(1,e);Y.Assert.areSame(26,b)},"When an attribute is set, a generalized 'change' event should be fired":function(){var c=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,f,a;b.addListener("change",function(h,g,j,i){d=true;e=g;f=j;a=i});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change' event was not fired");Y.Assert.areSame("attribute2",e,"The attributeName that was changed was not provided to the event correctly.");Y.Assert.areSame("brandNewValue",f,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute is set, a 'change:xxx' event should be fired for the changed attribute":function(){var c=Kevlar.extend(Kevlar.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,a;b.addListener("change:attribute2",function(f,h,g){d=true;e=h;a=g});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change:attribute2' event was not fired");Y.Assert.areSame("brandNewValue",e,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute with a `set()` function of its own is set, the 'change' events should be fired":function(){var b=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1",set:function(g){return g}},{name:"attribute2",set:function(h,g){}}]});var a=new b(),e=0,f,c=0,d;a.addListener("change:attribute1",function(g,h){e++;f=h});a.addListener("change:attribute2",function(g,h){c++;d=h});a.set("attribute1","attribute1value1");Y.Assert.areSame(1,e,"The attribute1 change event count should now be 1, with the initial value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value1",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should now be 2, with a new value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value2",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, being set to the same value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");a.set("attribute2","attribute2value1");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it");Y.Assert.areSame(1,c,"The attribute2 change event count should now be 1, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should have been undefined, as its set() function does not return anything");a.set("attribute2","attribute2value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it (2nd time)");Y.Assert.areSame(2,c,"The attribute2 change event count should now be 2, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should still be undefined, as its set() function does not return anything")},"When an attribute with only a `get()` function is set, the 'change' events should be fired with the value from the get function, not the raw value (for both the newValue, and oldValue)":function(){var d=Kevlar.extend(Kevlar.Model,{attributes:[{name:"myAttribute",get:function(h,g){return h+10}}]});var c=new d({myAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:myAttribute":function(h,i,g){f=i;b=g}});c.set("myAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from myAttribute's `get()` function")},"When an attribute with both a `set()` function, and `get()` function of its own is set, the 'change' events should be fired with the value from the `get()` function, not the raw value":function(){var d=Kevlar.extend(Kevlar.Model,{addAttributes:["baseAttribute",{name:"computedAttribute",set:function(h,g){g.set("baseAttribute",h)},get:function(h,g){return g.get("baseAttribute")+10}}]});var c=new d({baseAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:computedAttribute":function(h,i,g){f=i;b=g}});c.set("computedAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function")},"for compatibility with Backbone's Collection, set() should set the id property to the Model object itself with the idAttribute is changed":function(){var b=Kevlar.Model.extend({addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(d,c){return d+" "+c.get("attribute1")}}],idAttribute:"attribute1"});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute1val",a.id,"The model's `id` property should have been set to attribute1's value, as that is the idAttribute.");a.set("attribute1","newValue");Y.Assert.areSame("newValue",a.id,"The model's `id` property should have been set to attribute1's value after another set(), as that is the idAttribute.")}},{name:"Test get()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",get:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}}]})},"running get() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.get("attribute1"))},"running get() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.get("attribute1"))},"running get() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"running get() on an attribute with an initial value and a default value should return the initial value":function(){var a=new this.TestModel({attribute2:"initial value"});Y.Assert.areSame("initial value",a.get("attribute2"))},"running get() on an attribute with no initial value but does have a default value which is a function should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"running get() on an attribute with a `get` function defined should return the value that the `get` function returns":function(){var a=new this.TestModel({attribute1:"value1"});Y.Assert.areSame("value1 attribute2's default",a.get("attribute5"))}},{name:"Test raw()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",get:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute4",raw:function(b,a){return b+" "+a.get("attribute1")}}]})},"running raw() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.raw("attribute1"))},"running raw() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.raw("attribute1"))},"running raw() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.raw("attribute2"))},"running raw() on an attribute with a `get` function defined should return the *underlying* value, not the value that the `get` function returns":function(){var a=new this.TestModel({attribute3:"value1"});Y.Assert.areSame("value1",a.raw("attribute3"))},"running raw() on an attribute with a `raw` function defined should return the value that the `raw` function returns":function(){var a=new this.TestModel({attribute1:"value1",attribute4:"value4"});Y.Assert.areSame("value4 value1",a.raw("attribute4"))}},{name:"Test getDefault()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"A attribute with no defaultValue should return undefined when trying to retrieve its default value":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.getDefault("attribute1"))},"A defaultValue should be able to be retrieved directly when the attribute has one":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.getDefault("attribute2"))},"A defaultValue should be able to be retrieved directly when the defaultValue is a function that returns its default":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.getDefault("attribute3"))}},{name:"Test isDirty()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"isDirty() should return false after instantiating a Model with no data":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after instantiating a Model with initial data":function(){var a=new this.TestModel({attribute1:1,attribute2:2});Y.Assert.isFalse(a.isDirty())},"isDirty() should return true after setting an attribute's data":function(){var a=new this.TestModel();a.set("attribute1",1);Y.Assert.isTrue(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then rolling back the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.rollback();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then committing the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.commit();Y.Assert.isFalse(a.isDirty())}},{name:"Test isModified()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"isModified should return false if there are no changes on the model":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isModified())},"isModified should return true if there is at least one change on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");Y.Assert.isTrue(a.isModified())},"isModified should return true if there are multiple changes on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");a.set("attribute2","newValue2");Y.Assert.isTrue(a.isModified())},"isModified() should return false for particular attributes that have not been changed, even if there are other changes":function(){var a=new this.TestModel();a.set("attribute3","testing123");Y.Assert.isFalse(a.isModified("attribute1"),"attribute1, with no defaultValue, should not be modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2, with a defaultValue, should not be modified")},"isModified() should return true for particular attributes that have been changed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified");Y.Assert.isTrue(a.isModified("attribute2"),"attribute2 should be marked as modified")},"isModified() should return false for particular attributes that have been changed, but then committed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been committed, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been committed, and therefore not marked as modified")},"isModified() should return false for particular attributes that have been changed, but then rolled back":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.rollback();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been rolled back, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been rolled back, and therefore not marked as modified")}},{name:"Test getData()",setUp:function(){this.origNativeObjectConverter=Kevlar.data.NativeObjectConverter;var a=this.args={};Kevlar.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Kevlar.data.NativeObjectConverter=this.origNativeObjectConverter},"getData() should delegate to the singleton NativeObjectConverter to create an Object representation of its data":function(){var d=Kevlar.Model.extend({attributes:["attr1","attr2"]});var b=new d({attr1:"value1",attr2:"value2"});var c={raw:true};var a=b.getData(c);Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(c,this.args[1],"The second arg provided to NativeObjectConverter::convert() should have been the options object")}},{name:"Test getChanges()",setUp:function(){this.origNativeObjectConverter=Kevlar.data.NativeObjectConverter;var a=this.args={};Kevlar.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Kevlar.data.NativeObjectConverter=this.origNativeObjectConverter},"getChanges() should delegate to the singleton NativeObjectConverter to create an Object representation of its data, but only provide changed attributes for the attributes that should be returned":function(){var d=Kevlar.Model.extend({attributes:["attr1","attr2","attr3"]});var b=new d({attr1:"value1",attr2:"value2",attr3:"value3"});b.set("attr1","newValue1");b.set("attr2","newValue2");var a=b.getChanges({raw:true});var c=this.args[1];Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(true,c.raw,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'raw:true' option");Y.ArrayAssert.itemsAreSame(["attr1","attr2"],c.attributeNames,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'attributeNames' option, with the attributes that were changed")}},{name:"Test commit()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"committing changed data should cause the 'dirty' flag to be reset to false, and getChanges() to return an empty object":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();var b=a.getChanges();Y.Assert.areSame(0,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 0 properties");Y.Assert.isFalse(a.isDirty(),"The model should no longer be marked as 'dirty'")},"committing changed data should cause rollback() to have no effect":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();a.rollback();Y.Assert.areSame("new value 1",a.get("attribute1"),"attribute1 should have been 'new value 1'. rollback() should not have had any effect.");Y.Assert.areSame("new value 2",a.get("attribute2"),"attribute2 should have been 'new value 2'. rollback() should not have had any effect.")},"committing changed data should fire the 'commit' event":function(){var a=0;var b=new this.TestModel();b.addListener("commit",function(){a++});b.set("attribute1","new value 1");b.set("attribute2","new value 2");b.commit();Y.Assert.areSame(1,a,"The 'commit' event should have been fired exactly once after committing.")}},{name:"Test rollback()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},"rollback() should revert the model's values back to default values if before any committed set() calls":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.isUndefined(a.get("attribute1"));Y.Assert.areSame("attribute2's default",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values, when more than one set() call is made":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.set("attribute1","new value 1 - even newer");a.set("attribute2","new value 2 - even newer");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should fire the 'rollback' event":function(){var b=0;var a=new this.TestModel({attribute1:"orig1",attribute2:"orig2"});a.on("rollback",function(){b++});a.set("attribute1","new1");Y.Assert.areSame(0,b,"Initial condition: The rollback event should not have been fired yet");a.rollback();Y.Assert.areSame(1,b,"The rollback event should have been fired exactly once")}},{name:"Test load()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(b,a){return a.get("attribute1")+" "+a.get("attribute2")}},{name:"attribute5",set:function(b,a){return b+" "+a.get("attribute2")}}]})},_should:{error:{"load() should throw an error if there is no configured persistenceProxy":"Kevlar.Model::load() error: Cannot load. No persistenceProxy."}},"load() should throw an error if there is no configured persistenceProxy":function(){var a=new this.TestModel({});a.load();Y.Assert.fail("load() should have thrown an error with no configured persistenceProxy")},"load() should delegate to its persistenceProxy's read() method to retrieve the data":function(){var a=0;var b=Kevlar.persistence.Proxy.extend({read:function(f,e){a++}});var d=this.TestModel.extend({persistenceProxy:new b()});var c=new d();c.load();Y.Assert.areSame(1,a,"The persistenceProxy's read() method should have been called exactly once")}},{name:"Test save()",ttype:"testsuite",items:[{name:"General save() tests",_should:{error:{"save() should throw an error if there is no configured persistenceProxy":"Kevlar.Model::save() error: Cannot save. No persistenceProxy."}},"save() should throw an error if there is no configured persistenceProxy":function(){var b=Kevlar.Model.extend({});var a=new b();a.save();Y.Assert.fail("save() should have thrown an error with no configured persistenceProxy")},"save() should delegate to its persistenceProxy's create() method to persist changes when the Model does not have an id set":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:a});var b=new d();b.save();try{JsMockito.verify(a).create()}catch(c){Y.Assert.fail("The persistenceProxy's update() method should have been called exactly once. "+c)}},"save() should delegate to its persistenceProxy's update() method to persist changes, when the Model has an id":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:a});var b=new d({id:1});b.save();try{JsMockito.verify(a,JsMockito.Verifiers.once()).update()}catch(c){Y.Assert.fail("The persistenceProxy's update() method should have been called exactly once. "+c)}}},{name:"save() callbacks tests",setUp:function(){this.mockProxy=JsMockito.mock(Kevlar.persistence.Proxy);this.mockProxy.create=this.mockProxy.update=function(b,a){if(a.success){a.success.call(a.scope||window)}if(a.error){a.error.call(a.scope||window)}if(a.complete){a.complete(a.scope||window)}};this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1"],persistenceProxy:this.mockProxy})},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully creates":function(){var c=0,a=0;var b=new this.Model();b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while creating":function(){var c=0,a=0;var b=new this.Model();b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully updates":function(){var c=0,a=0;var b=new this.Model({id:1});b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while updating":function(){var c=0,a=0;var b=new this.Model({id:1});b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")}},{name:"Test basic persistence",setUp:function(){this.Model=Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"]})},"Model attributes that have been persisted should not be persisted again if they haven't changed since the last persist":function(){var c;var a=Kevlar.persistence.Proxy.extend({update:function(f,e){c=f.getChanges();e.success.call(e.scope)}});var d=this.Model.extend({persistenceProxy:new a()});var b=new d({id:1});b.set("attribute1","newattribute1value");b.save();Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The dataToPersist should only have one key after attribute1 has been changed");Y.ObjectAssert.ownsKeys(["attribute1"],c,"The dataToPersist should have 'attribute1'");b.set("attribute2","newattribute2value");b.save();Y.Assert.areSame(1,Kevlar.util.Object.length(c),"The dataToPersist should only have one key after attribute2 has been changed");Y.ObjectAssert.ownsKeys(["attribute2"],c,"The dataToPersist should have 'attribute2'")}},{name:"Test concurrent persistence and model updates",createModel:function(b){var a=Kevlar.persistence.Proxy.extend({update:function(d,c){window.setTimeout(function(){c.success.call(c.scope||window)},b)}});return Kevlar.Model.extend({addAttributes:["id","attribute1","attribute2"],persistenceProxy:new a()})},"Model attributes that are updated (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue1",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.")})}});a.set("attribute1","newValue1");c.wait(100)},"Model attributes that are updated *more than once* (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue11",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.");a.rollback();Y.Assert.areSame("origValue1",a.get("attribute1"),"The value for attribute1 should have been rolled back to its original value")})}});a.set("attribute1","newValue1");a.set("attribute1","newValue11");c.wait(100)}}]},{name:"Test destroy()",ttype:"testsuite",items:[{name:"General destroy() tests",_should:{error:{"destroy() should throw an error if there is no configured persistenceProxy":"Kevlar.Model::destroy() error: Cannot destroy. No persistenceProxy."}},"destroy() should throw an error if there is no configured persistenceProxy":function(){var b=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b();a.destroy();Y.Assert.fail("destroy() should have thrown an error with no configured persistenceProxy")},"destroy() should delegate to its persistenceProxy's destroy() method to persist the destruction of the model":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);var d=Kevlar.Model.extend({persistenceProxy:a});var b=new d();b.destroy();try{JsMockito.verify(a,JsMockito.Verifiers.once()).destroy()}catch(c){Y.Assert.fail("The model should have delegated to the destroy method exactly once.")}},"upon successful destruction of the Model, the Model should fire its 'destroy' event":function(){var a=JsMockito.mock(Kevlar.persistence.Proxy);a.destroy=function(f,e){e.success.call(e.scope)};var d=Kevlar.Model.extend({persistenceProxy:a});var b=new d();var c=false;b.addListener("destroy",function(){c=true});b.destroy();Y.Assert.isTrue(c,"Should have fired its destroy event")}},{name:"destroy() callbacks tests",setUp:function(){this.mockProxy=JsMockito.mock(Kevlar.persistence.Proxy);this.mockProxy.destroy=function(b,a){if(a.success){a.success.call(a.scope)}if(a.error){a.error.call(a.scope)}if(a.complete){a.complete(a.scope)}}},"destroy() should call its 'success' and 'complete' callbacks if the persistenceProxy is successful":function(){var c=0,a=0;var d=Kevlar.Model.extend({attributes:["attribute1"],persistenceProxy:this.mockProxy});var b=new d();b.destroy({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error":function(){var e=0,b=0;var a=JsMockito.mock(Kevlar.persistence.Proxy);a.destroy=function(g,f){f.error.call(f.scope);f.complete(f.scope)};var d=Kevlar.Model.extend({attributes:["attribute1"],persistenceProxy:this.mockProxy});var c=new d();c.destroy({error:function(){e++},complete:function(){b++},scope:this});Y.Assert.areSame(1,e,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,b,"The 'complete' function should have been called exactly once")}}]}]}));tests.unit.persistence.add(new Ext.test.TestSuite({name:"Kevlar.persistence.RestProxy",items:[{name:"Test create",ttype:"testsuite",items:[{name:"General create() tests","create() should populate the model with any response data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Kevlar.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Kevlar.Model);b.create(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"create()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'POST'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.create(b);Y.Assert.areSame("POST",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{create:"PUT"}});var c=new d();c.create(b);Y.Assert.areSame("PUT",a)}}]},{name:"Test read",ttype:"testsuite",items:[{name:"General read() tests","read() should populate the model data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Kevlar.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Kevlar.Model);b.read(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"read()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'GET'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.read(b);Y.Assert.areSame("GET",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{read:"POST"}});var c=new d();c.read(b);Y.Assert.areSame("POST",a)}}]},{name:"Test update()",ttype:"testsuite",items:[{name:"General update() tests","update() should NOT actually call the ajax method when no attributes have been changed":function(){var a=0;var d=Kevlar.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({});c.update(b);Y.Assert.areSame(0,a,"The proxy's ajax() method should not have not been called, since there are no changes")},"update() should in fact call the ajax method when attributes have been changed":function(){var a=0;var d=Kevlar.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});c.update(b);Y.Assert.areSame(1,a,"The proxy's ajax() method should have been called, since there are changes to persist")}},{name:"Test update() callbacks",setUp:function(){this.ajaxCallCount=0;this.TestProxy=Kevlar.persistence.RestProxy.extend({ajax:jQuery.proxy(function(a){this.ajaxCallCount++;if(a.success){a.success()}if(a.error){a.error()}if(a.complete){a.complete()}},this)})},"The 'success' and 'complete' callbacks provided to update() should be called if no attributes have been changed, and it does not need to do its ajax request":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,this.ajaxCallCount,"The ajax method should not have been called");Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything")},"The 'success' and 'complete' callbacks provided to update() should be called if the ajax request is successful":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")},"The 'error' and 'complete' callbacks provided to update() should be called if the ajax request fails":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{error:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'error' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")}},{name:"HTTP method tests","By default, the ajax function should be called with the HTTP method 'PUT'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.update(b);Y.Assert.areSame("PUT",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{update:"POST"}});var c=new d();c.update(b);Y.Assert.areSame("POST",a)}},{name:"Test incremental updates",setUp:function(){this.mockModel=JsMockito.mock(Kevlar.Model);JsMockito.when(this.mockModel).getData().thenReturn({attribute1:"value1",attribute2:"value2"});JsMockito.when(this.mockModel).getChanges().thenReturn({attribute2:"value2"})},"update() should provide the full set of data to the ajax method if the proxy is not set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Kevlar.persistence.RestProxy.extend({ajax:d,incremental:false});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(2,Kevlar.util.Object.length(a),"The dataPersisted have exactly 2 keys, one for each of the attributes in the model");Y.ObjectAssert.ownsKeys(["attribute1","attribute2"],a);Y.Assert.areEqual("value1",a.attribute1);Y.Assert.areEqual("value2",a.attribute2)},"update() should provide only the changed data if the proxy is set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Kevlar.persistence.RestProxy.extend({ajax:d,incremental:true});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(1,Kevlar.util.Object.length(a),"The dataPersisted have exactly 1 key, the one that was changed");Y.ObjectAssert.ownsKeys(["attribute2"],a);Y.Assert.areEqual("value2",a.attribute2)}}]},{name:"Test destroy",ttype:"testsuite",items:[{name:"Test destroy()'s callbacks","The 'success' and 'complete' callbacks provided to destroy() should be called if the ajax request is successful":function(){var f=function(g){g.success();g.complete()};var e=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:f});var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new e();var d=0,a=0;c.destroy(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")},"The 'error' and 'complete' callbacks provided to destroy() should be called if the ajax request fails":function(){var e=function(g){g.error();g.complete()};var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:e});var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new d();var f=0,a=0;c.destroy(b,{error:function(){f++},complete:function(){a++}});Y.Assert.areSame(1,f,"The 'error' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")}},{name:"destroy()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'DELETE'":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.destroy(b);Y.Assert.areSame("DELETE",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Kevlar.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Kevlar.extend(Kevlar.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{destroy:"POST"}});var c=new d();c.destroy(b);Y.Assert.areSame("POST",a)}}]},{name:"Test buildUrl()","buildUrl() should return simply the configured urlRoot, if the 'appendId' config is false":function(){var a=JsMockito.mock(Kevlar.Model);JsMockito.when(a).getId().thenReturn(42);var b=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl",appendId:false});Y.Assert.areSame("/testUrl",b.buildUrl(a),"buildUrl() should have simply still returned the url")},"buildUrl() should return the configured urlRoot with the model's id, if the 'appendId' config is true":function(){var a=JsMockito.mock(Kevlar.Model);JsMockito.when(a).getId().thenReturn(42);var c=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl",appendId:true});Y.Assert.areSame("/testUrl/42",c.buildUrl(a),"buildUrl() should have returned the url with the id appended");var b=new Kevlar.persistence.RestProxy({urlRoot:"/testUrl/",appendId:true});Y.Assert.areSame("/testUrl/42",b.buildUrl(a),"buildUrl() should have returned the url with the id appended")}}]}));tests.unit.util.add(new Ext.test.TestSuite({name:"Kevlar.util.Object",items:[{name:"Test clone()","clone() should return primitive types as-is":function(){Y.Assert.areSame(undefined,Kevlar.util.Object.clone(undefined),"clone() not returning undefined when provided undefined.");Y.Assert.areSame(null,Kevlar.util.Object.clone(null),"clone() not returning null when provided null.");Y.Assert.areSame(true,Kevlar.util.Object.clone(true),"clone() not returning true when provided true.");Y.Assert.areSame(false,Kevlar.util.Object.clone(false),"clone() not returning false when provided false.");Y.Assert.areSame(0,Kevlar.util.Object.clone(0),"clone() not returning 0 when provided 0.");Y.Assert.areSame(1,Kevlar.util.Object.clone(1),"clone() not returning 1 when provided 1.");Y.Assert.areSame("",Kevlar.util.Object.clone(""),"clone() not returning empty string when provided an empty string.");Y.Assert.areSame("hi",Kevlar.util.Object.clone("hi"),"clone() not returning string 'hi' when provided string 'hi'.")},"clone() should copy a Date object":function(){var a=new Date(2012,1,1,1,1,1,1);var b=Kevlar.util.Object.clone(a);Y.Assert.areNotSame(a,b,"The copy should not be a reference to the original object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(a,b),"The copy should have the same date value")},"clone() should copy a Date object that is nested within another object":function(){var b=new Date(2012,1,1,1,1,1,1);var c={a:b};var a=Kevlar.util.Object.clone(c);Y.Assert.areNotSame(c,a,"The copy of the object should not be a reference to the input object");Y.Assert.areNotSame(b,a.a,"The date in the 'a' property should be a copy, not a reference to the same object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(c,a),"clone() should have copied the object");Y.Assert.isTrue(Kevlar.util.Object.isEqual(b,a.a),"clone() should have copied the Date object")},"clone() should copy an array of primitives":function(){var a=[1,2,3,4,5];Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to array.");Y.Assert.isTrue(Kevlar.util.Object.isEqual([1,2,3,4,5],Kevlar.util.Object.clone(a)),"clone() not properly copying a simple array.")},"clone() should deep copy an array of mixed primitives and objects":function(){var a=[{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]];Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to complex array.");Y.Assert.isTrue(Kevlar.util.Object.isEqual([{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]],Kevlar.util.Object.clone(a)),"clone() not properly deep copying a complex array.");Y.Assert.areNotSame(a[0],Kevlar.util.Object.clone(a)[0],"clone() not properly deep copying a complex array. first element has same reference for original and copy.");Y.Assert.areNotSame(a[0].a,Kevlar.util.Object.clone(a)[0].a,"clone() not properly deep copying a complex array. first element, 'a' object, has same reference for original and copy.");Y.Assert.areSame(a[0].a,Kevlar.util.Object.clone(a,false)[0].a,"clone() not properly shallow copying a complex array. first element, 'a' object, does not have same reference for original and copy.")},"clone() should copy a simple object of primitives":function(){var a={a:1,b:2};Y.Assert.areNotSame(a,Kevlar.util.Object.clone(a),"clone() returning same reference to simple object.");Y.Assert.isTrue(Kevlar.util.Object.isEqual({a:1,b:2},Kevlar.util.Object.clone(a)),"clone() not properly copying a simple object.")},"clone() should deep copy an object of primitives, nested arrays, and nested objects":function(){var a=new Date(2011,1,1);var b={a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]],d:a};Y.Assert.areNotSame(b,Kevlar.util.Object.clone(b),"clone() returning same reference to complex object.");Y.Assert.isTrue(Kevlar.util.Object.isEqual({a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]],d:a},Kevlar.util.Object.clone(b)),"clone() not properly deep copying a complex object.");Y.Assert.areNotSame(b.b,Kevlar.util.Object.clone(b).b,"clone() not properly deep copying a complex object. property 'b' has same reference for original and copy.");Y.Assert.areNotSame(b.b.c,Kevlar.util.Object.clone(b).b.c,"clone() not properly deep copying a complex object. property 'b.c' has same reference for original and copy. Nested object inside nested object not getting copied.");Y.Assert.areSame(b.b.c,Kevlar.util.Object.clone(b,false).b.c,"clone() with 'deep' set to false (shallow copy mode) is still deep copying a complex object. property 'b.c' does not have same reference for original and copy.");Y.Assert.areNotSame(a,Kevlar.util.Object.clone(b).d,"The Date object in complexObj.d should have been a copy of the Date object, not a reference to the same object")},"clone() should not copy prototype properties of instantiated objects":function(){var a=function(){this.ownVar=1};a.prototype.prototypeVar=2;var b=new a();var c=Kevlar.util.Object.clone(b);Y.Assert.isTrue(c.hasOwnProperty("ownVar"),"clone() did not copy the owned property 'ownVar'");Y.Assert.areSame(1,c.ownVar,"clone() did not copy the owned property 'ownVar' with the correct value");Y.Assert.isFalse(c.hasOwnProperty("prototypeVar"),"clone() copied the prototype property 'prototypeVar'. It should not have.")}},{name:"Test isEqual()","isEqual() should work with all datatype comparisons (primitive and array/object)":function(){var b=Kevlar.util.Object.isEqual;Y.Assert.isTrue(b(undefined,undefined),"Error: undefined !== undefined");Y.Assert.isFalse(b(undefined,null),"Error: undefined === null");Y.Assert.isFalse(b(undefined,true),"Error: undefined === true");Y.Assert.isFalse(b(undefined,false),"Error: undefined === false");Y.Assert.isFalse(b(undefined,0),"Error: undefined === 0");Y.Assert.isFalse(b(undefined,""),"Error: undefined === ''");Y.Assert.isFalse(b(undefined,{}),"Error: undefined === {}");Y.Assert.isFalse(b(undefined,{a:1}),"Error: undefined === { a : 1 }");Y.Assert.isFalse(b(undefined,[]),"Error: undefined === []");Y.Assert.isFalse(b(undefined,[1,2,3]),"Error: undefined === [ 1,2,3 ]");Y.Assert.isFalse(b(undefined,42),"Error: undefined === 42");Y.Assert.isFalse(b(undefined,"test"),"Error: undefined === 'test'");Y.Assert.isTrue(b(null,null),"Error: null !== null");Y.Assert.isFalse(b(null,undefined),"Error: null === undefined");Y.Assert.isFalse(b(null,true),"Error: null === true");Y.Assert.isFalse(b(null,false),"Error: null === false");Y.Assert.isFalse(b(null,0),"Error: null === 0");Y.Assert.isFalse(b(null,""),"Error: null === ''");Y.Assert.isFalse(b(null,{}),"Error: null === {}");Y.Assert.isFalse(b(null,{a:1}),"Error: null === { a : 1 }");Y.Assert.isFalse(b(null,[]),"Error: null === []");Y.Assert.isFalse(b(null,[1,2,3]),"Error: null === [ 1,2,3 ]");Y.Assert.isFalse(b(null,42),"Error: null === 42");Y.Assert.isFalse(b(null,"test"),"Error: null === 'test'");Y.Assert.isTrue(b(true,true),"Error: true !== true");Y.Assert.isTrue(b(false,false),"Error: false !== true");Y.Assert.isFalse(b(true,false),"Error: true === false");Y.Assert.isFalse(b(false,true),"Error: false === true");Y.Assert.isFalse(b(false,0),"Error: false === 0");Y.Assert.isFalse(b(true,1),"Error: true === 1");Y.Assert.isFalse(b(false,""),"Error: false === ''");Y.Assert.isFalse(b(true,"true"),"Error: true === 'true'");Y.Assert.isTrue(b(0,0),"Error: 0 !== 0");Y.Assert.isTrue(b(1,1),"Error: 1 !== 1");Y.Assert.isTrue(b(-1,-1),"Error: -1 !== -1");Y.Assert.isFalse(b(0,1),"Error: 0 === 1");Y.Assert.isFalse(b(1,0),"Error: 1 === 0");Y.Assert.isFalse(b(1,2),"Error: 1 === 2");Y.Assert.isFalse(b(0,""),"Error: 0 === ''");Y.Assert.isFalse(b(1,"1"),"Error: 1 === '1'");Y.Assert.isTrue(b("",""),"Error: '' !== ''");Y.Assert.isTrue(b("asdf","asdf"),"Error: 'asdf' !== 'asdf'");Y.Assert.isFalse(b("",0),"Error: '' === 0");Y.Assert.isFalse(b("asdf","asdf2"),"Error: 'asdf' === 'asdf2'");Y.Assert.isFalse(b(0,"0"),"Error: 0 === '0'");Y.Assert.isFalse(b("0",0),"Error: '0' === 0");Y.Assert.isFalse(b(1,"1"),"Error: 1 === '1'");Y.Assert.isFalse(b("1",1),"Error: '1' === 1");Y.Assert.isFalse(b({},null),"Error: {} === null");Y.Assert.isFalse(b({},undefined),"Error: {} === undefined");Y.Assert.isFalse(b({},true),"Error: {} === true");Y.Assert.isFalse(b({},false),"Error: {} === false");Y.Assert.isFalse(b({},0),"Error: {} === 0");Y.Assert.isFalse(b({},1),"Error: {} === 1");Y.Assert.isFalse(b({},""),"Error: {} === ''");Y.Assert.isFalse(b({},"test"),"Error: {} === 'test'");Y.Assert.isTrue(b({},{}),"Error: {} !== {}");Y.Assert.isFalse(b({},{a:1}),"Error: {} === { a : 1 }");Y.Assert.isFalse(b({},[]),"Error: {} === []");Y.Assert.isFalse(b({},[1,2,3]),"Error: {} === [ 1,2,3 ]");Y.Assert.isFalse(b([],null),"Error: [] === null");Y.Assert.isFalse(b([],undefined),"Error: [] === undefined");Y.Assert.isFalse(b([],true),"Error: [] === true");Y.Assert.isFalse(b([],false),"Error: [] === false");Y.Assert.isFalse(b([],0),"Error: [] === 0");Y.Assert.isFalse(b([],1),"Error: [] === 1");Y.Assert.isFalse(b([],""),"Error: [] === ''");Y.Assert.isFalse(b([],"test"),"Error: [] === 'test'");Y.Assert.isFalse(b([],{}),"Error: [] === {}");Y.Assert.isFalse(b([],{a:1}),"Error: [] === { a : 1 }");Y.Assert.isTrue(b([],[]),"Error: [] !== []");Y.Assert.isFalse(b([],[1,2,3]),"Error: [] === [ 1,2,3 ]");var a=new Date(2012,1,1,10,10,10,10);Y.Assert.isFalse(b(a,null),"Error: date === null");Y.Assert.isFalse(b(a,undefined),"Error: date === undefined");Y.Assert.isFalse(b(a,true),"Error: date === true");Y.Assert.isFalse(b(a,false),"Error: date === false");Y.Assert.isFalse(b(a,0),"Error: date === 0");Y.Assert.isFalse(b(a,1),"Error: date === 1");Y.Assert.isFalse(b(a,""),"Error: date === ''");Y.Assert.isFalse(b(a,"test"),"Error: date === 'test'");Y.Assert.isFalse(b(a,{}),"Error: date === {}");Y.Assert.isFalse(b(a,{a:1}),"Error: date === { a : 1 }");Y.Assert.isFalse(b(a,[]),"Error: date === []");Y.Assert.isFalse(b(a,[1,2,3]),"Error: date === [ 1,2,3 ]");Y.Assert.isFalse(b(a,new Date(2000,1,1,1,1,1,1)),"Error: date === a date with a different date/time");Y.Assert.isTrue(b(a,new Date(2012,1,1,10,10,10,10)),"Error: date !== a date with a the same date/time")},"isEqual() should work with deep object comparisons":function(){var v=Kevlar.util.Object.isEqual;var y={a:"text",b:[0,1]};var x={a:"text",b:[0,1]};var w={a:"text",b:0};var u={a:"text",b:false};var t={a:"text",b:[1,0]};var s={a:"text",b:[1,0],f:function(){this.f=this.b}};var r={a:"text",b:[1,0],f:function(){this.f=this.b}};var q={a:"text",b:[1,0],f:function(){this.a=this.b}};var p={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var o={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var n={a:"text",b:null};var m={a:"text",b:undefined};Y.Assert.isTrue(v(y,x),"Error w/ object comparison. a !== b");Y.Assert.isFalse(v(y,w),"Error w/ object comparison. a === c");Y.Assert.isFalse(v(w,u),"Error w/ object comparison. c === d");Y.Assert.isFalse(v(y,t),"Error w/ object comparison. a === e");Y.Assert.isTrue(v(s,r),"Error w/ object comparison. f !== g");Y.Assert.isFalse(v(r,q),"Error w/ object comparison. g === h");Y.Assert.isTrue(v(p,o),"Error w/ object comparison. i !== j");Y.Assert.isFalse(v(u,n),"Error w/ object comparison. d === k");Y.Assert.isFalse(v(n,p),"Error w/ object comparison. k === i")},"isEqual() should work with deep array comparisons":function(){var B=Kevlar.util.Object.isEqual;var M=[];var L=[];var K=[1];var J=[1];var I=[2];var H=[2];var G=[1,2,3];var F=[1,2,3];var E=[1,{a:1,b:2},3];var D=[1,{a:1,b:2},3];var C=[[1,2,3],{a:1,b:2},3];var A=[[1,2,3],{a:1,b:2},3];var z=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var y=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var x=[[1,2,3],{a:1,b:2},4];var w=[[1,2,3],{a:11,b:2},4];var v=[[1,22,3],{a:1,b:2},4];var u=[[1,{a:1,b:2,c:3},[1,1,3]],{a:1,b:[1,2]},{c:3}];var t=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[2,2]},{c:3}];Y.Assert.isTrue(B(M,L),"Error w/ array comparison. a !== b");Y.Assert.isTrue(B(K,J),"Error w/ array comparison. c !== d");Y.Assert.isTrue(B(I,H),"Error w/ array comparison. e !== f");Y.Assert.isTrue(B(G,F),"Error w/ array comparison. g !== h");Y.Assert.isTrue(B(E,D),"Error w/ array comparison. i !== j");Y.Assert.isTrue(B(C,A),"Error w/ array comparison. k !== l");Y.Assert.isTrue(B(z,y),"Error w/ array comparison. m !== n");Y.Assert.isFalse(B(M,K),"Error w/ array comparison. a === c");Y.Assert.isFalse(B(L,J),"Error w/ array comparison. b === d");Y.Assert.isFalse(B(K,I),"Error w/ array comparison. c === e");Y.Assert.isFalse(B(J,H),"Error w/ array comparison. d === f");Y.Assert.isFalse(B(I,G),"Error w/ array comparison. e === g");Y.Assert.isFalse(B(H,F),"Error w/ array comparison. f === h");Y.Assert.isFalse(B(G,E),"Error w/ array comparison. g === i");Y.Assert.isFalse(B(F,D),"Error w/ array comparison. h === j");Y.Assert.isFalse(B(E,C),"Error w/ array comparison. i === k");Y.Assert.isFalse(B(D,A),"Error w/ array comparison. j === l");Y.Assert.isFalse(B(C,z),"Error w/ array comparison. k === m");Y.Assert.isFalse(B(A,y),"Error w/ array comparison. l === n");Y.Assert.isFalse(B(E,x),"Error w/ array comparison. i === o");Y.Assert.isFalse(B(C,w),"Error w/ array comparison. k === p");Y.Assert.isFalse(B(z,u),"Error w/ array comparison. m === r");Y.Assert.isFalse(B(y,t),"Error w/ array comparison. n === s")},"isEqual() should be able to shallow compare, with the 'deep' flag set to false, in case objects refer to each other":function(){var g=Kevlar.util.Object.isEqual;var j={};var i={};j.obj2=i;i.obj1=j;var d=[j,i];var c=[j,i];var f;try{f=Kevlar.util.Object.isEqual(d,c,false)}catch(h){Y.Assert.fail("Error w/ shallow array comparison and deep flag set to false. Comparison must be going deep, as this error would come from call stack size being reached.")}Y.Assert.isTrue(f,"Error w/ shallow array comparison. a !== b")}},{name:"Test objLength()","objLength() should return 0 for an empty object":function(){var a={};Y.Assert.areSame(0,Kevlar.util.Object.length(a))},"objLength() should return 0 for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.areSame(0,Kevlar.util.Object.length(b))},"objLength() should return the number of owned properties in the object":function(){var a={prop1:"1",prop2:"2"};Y.Assert.areSame(2,Kevlar.util.Object.length(a))},"objLength() should return the number of owned properties in the object, even if they are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.areSame(5,Kevlar.util.Object.length(a))}},{name:"Test isEmpty()","isEmpty() should return true for an empty object":function(){var a={};Y.Assert.isTrue(Kevlar.util.Object.isEmpty(a))},"isEmpty() should return true for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.isTrue(Kevlar.util.Object.isEmpty(b))},"isEmpty() should return false if the object owns properties":function(){var a={prop1:"1",prop2:"2"};Y.Assert.isFalse(Kevlar.util.Object.isEmpty(a))},"isEmpty() should return false if the object owns properties, even if the properties are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.isFalse(Kevlar.util.Object.isEmpty(a))}},{name:"Test keysToArray()","keysToArray() should return an empty array for an empty object":function(){var b={};var a=Kevlar.util.Object.keysToArray(b);Y.Assert.areSame(0,a.length)},"keysToArray() should return an empty array for an object with only prototype properties":function(){var b=function(){};b.prototype.prop1=1;b.prototype.prop2=2;var c=new b();var a=Kevlar.util.Object.keysToArray(c);Y.Assert.areSame(0,a.length)},"keysToArray() should return an array of the key names of the object":function(){var b={prop1:1,prop2:2};var a=Kevlar.util.Object.keysToArray(b);Y.ArrayAssert.itemsAreSame(["prop1","prop2"],a)},"keysToArray() should return an array of the key names of the object, but ignore prototype properties":function(){var b=function(){this.myOwnedProp=1};b.prototype.prop1=1;b.prototype.prop2=2;var c=new b();var a=Kevlar.util.Object.keysToArray(c);Y.ArrayAssert.itemsAreSame(["myOwnedProp"],a)}}]}));tests.unit.util.add(new Ext.test.TestSuite({name:"Kevlar.util.Observable",setUp:function(){},items:[{name:"Test fireEvent()","firing an event with two listeners, and the first one returns false, should not stop the second from running (returning false should only stop event propagation)":function(){var c=new Kevlar.util.Observable();c.addEvents("testevent");var b=false,a=false;c.addListener("testevent",function(){b=true;return false});c.addListener("testevent",function(){a=true});c.fireEvent("testevent");Y.Assert.isTrue(b,"The first event handler should have been executed");Y.Assert.isTrue(a,"The second event handler should have been executed, even though the first returned false. Returning false should not prevent other handlers from executing, only stop event bubbling.")},"firing an event where one of its handlers returns false should have the call to fireEvent() return false":function(){var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the first its two handlers returned false should have caused the return from fireEvent() to be false.");var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the second of its two handlers returned false should have caused the return from fireEvent() to be false.");var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});Y.Assert.isFalse(a.fireEvent("testevent"),"Firing the event where the second of its three handlers returned false should have caused the return from fireEvent() to be false.")},"firing an event where none of its handlers returns false should have the call to fireEvent() return true":function(){var a=new Kevlar.util.Observable();a.addEvents("testevent");a.addListener("testevent",function(){});a.addListener("testevent",function(){});Y.Assert.isTrue(a.fireEvent("testevent"),"Firing the event where none of its handlers returned false should have caused the return from fireEvent() to be true.")}},{name:"Test removeListener()","removeListener() should accept an object literal of events to remove":function(){var e=new Kevlar.util.Observable();e.addEvents("evt1","evt2");var c=0,a=0,f=function(){c++},d=function(){a++},b={};e.addListener("evt1",f,b);e.addListener("evt2",d,b);e.fireEvent("evt1");e.fireEvent("evt2");Y.Assert.areSame(1,c,"Initial condition firing should set evt1count to 1");Y.Assert.areSame(1,a,"Initial condition firing should set evt2count to 1");e.removeListener({evt1:f,evt2:d,scope:b});e.fireEvent("evt1");e.fireEvent("evt2");Y.Assert.areSame(1,c,"The evt1count should still be at 1, because the handler was removed");Y.Assert.areSame(1,a,"The evt2count should still be at 1, because the handler was removed")}},{name:"Test event bubbling","firing an event where none of its handlers returns false should have allowed the event to bubble":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"Firing the event where none of its handlers returned false should have allowed the event to bubble.")},"firing an event where its one handler returns false should have prevented the event from bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){return false});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event its one handler returned false should have prevented the event from bubbling.")},"firing an event where one of its handlers returns false should have prevented the event from bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){return false});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event where the first of its two handlers returned false should have prevented the event from bubbling.");var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble("testevent");var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.addListener("testevent",function(){return false});a.fireEvent("testevent");Y.Assert.isFalse(c,"Firing the event where the second of its two handlers returned false should have prevented the event from bubbling.")},"Providing the enableBubble() method an object or array of objects should enable bubbling just the same as a string or array of strings":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent"});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"The enableBubble() method should have been able to take an object as its argument to enable bubbling for an event.")},"Providing the enableBubble() method a bubbleFn that just returns false should prevent bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent",bubbleFn:function(d){return false}});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isFalse(c,"A bubbleFn provided to enableBubble() that simply returns false should have prevented the event from bubbling.")},"Providing the enableBubble() method a bubbleFn that returns nothing should NOT prevent bubbling":function(){var b=new Kevlar.util.Observable();var a=new Kevlar.util.Observable();a.getBubbleTarget=function(){return b};a.addEvents("testevent");a.enableBubble({eventName:"testevent",bubbleFn:function(d){}});var c=false;b.addListener("testevent",function(){c=true});a.addListener("testevent",function(){});a.fireEvent("testevent");Y.Assert.isTrue(c,"A bubbleFn provided to enableBubble() that returns nothing should have NOT prevented the event from bubbling.")}}]}));(function(){tests.integration=new Ext.test.TestSuite("integration");Ext.test.Session.addSuite(tests.integration)})();tests.integration.add(new Ext.test.TestSuite({name:"Collection with Models",items:[{name:"Test Model Events","changing an attribute in a model should fire a general 'change' event in the Collection":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var e=Kevlar.Collection.extend({model:d});var j=new d({attr:"model1Value1"}),h=new d({attr:"model2Value1"}),f=new e([j,h]);var b=0,a,i,g,c;f.on("change",function(m,l,n,k){b++;a=m;i=l;g=n;c=k});j.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(j,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model1 should have been fired with the correct attribute name");Y.Assert.areSame("model1Value2",g,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");h.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(h,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model2 should have been fired with the correct attribute name");Y.Assert.areSame("model2Value2",g,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"changing an attribute in a model should fire an attribute-specific 'change' event in the Collection":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var e=Kevlar.Collection.extend({model:d});var i=new d({attr:"model1Value1"}),h=new d({attr:"model2Value1"}),f=new e([i,h]);var b=0,a,g,c;f.on("change:attr",function(k,l,j){b++;a=k;g=l;c=j});i.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(i,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("model1Value2",g,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");h.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(h,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("model2Value2",g,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"Any event that the Model fires should be relayed by the Collection":function(){var b=Kevlar.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var f=Kevlar.Collection.extend({model:b});var j=new b(),i=new b(),g=new f([j,i]);var c=0,h,e,d,a;g.on("testevent",function(n,m,l,k){c++;h=n;e=m;d=l;a=k});j.fireEvent("testevent",j,1,2,3);Y.Assert.areSame(1,c,"The testevent should have been called exactly once");Y.Assert.areSame(j,h,"The testevent should have been called with the model (as it was provided)");Y.Assert.areSame(1,e,"arg1 should have been provided");Y.Assert.areSame(2,d,"arg2 should have been provided");Y.Assert.areSame(3,a,"arg3 should have been provided")},"After a model has been removed from the Collection, the collection should no longer relay its events":function(){var e=Kevlar.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var a=Kevlar.Collection.extend({model:e});var f=new e(),d=new e(),c=new a([f,d]);var b=0;c.on("testevent",function(){b++});c.remove(f);f.fireEvent("testevent");Y.Assert.areSame(0,b,"The testevent should *not* have been fired from the collection, as the child model was removed")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelAttribute",items:[{name:"Test provided set() function","The set() function provided to a ModelAttribute should be passed the instantiated Model if a 'modelClass' config is provided":function(){var d;var b=Kevlar.Model.extend({attributes:["someAttr"]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"model",modelClass:b,set:function(e){d=e;return e}}]});var a=new c({attr:{someAttr:1}});Y.Assert.isInstanceOf(b,d)}},{name:"Test retrieving the inner model from the outer model after it is set","The get() method should be able to retrieve the Model after it has been set":function(){var b=Kevlar.Model.extend({attributes:["someValue"]});var d=Kevlar.Model.extend({attributes:[{name:"innerModel",type:"model",modelClass:b}]});var a=new d({innerModel:{someValue:1}});var c=a.get("innerModel");Y.Assert.isInstanceOf(b,c)}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelCache",items:[{name:"Duplicate models should not be able to be instantiated","Instatiating two models of different types, but the same instance ID, should *not* be 'combined' into the same instance":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var a=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var d=new b({id:1});var c=new a({id:1});Y.Assert.areNotSame(d,c)},"Instatiating two models of the same type, but the different instance IDs, should *not* be 'combined' into the same instance":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:2});Y.Assert.areNotSame(c,a)},"Instantiating two models of both the same type, and which have the same instance ID, should really become the same single instance (i.e. not duplicating it). The same reference should be returned when constructing the duplicate model":function(){var b=Kevlar.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:1});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object")},"Instantiating two models with the same ID should combine the initial data, with still, only one actual instance should be created":function(){var b=Kevlar.Model.extend({attributes:["id","firstName","lastName"],idAttribute:"id"});var c=new b({id:1,firstName:"Joe"});var a=new b({id:1,lastName:"Shmo"});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object");Y.Assert.areSame("Joe",c.get("firstName"));Y.Assert.areSame("Shmo",c.get("lastName"))}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with NativeObjectConverter",items:[{name:"Test getData()",ttype:"suite",items:[{"Model::getData() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=a.getData();Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"Model::getData() should return the data by running attributes' `get` functions (not just returning the raw data), when the `raw` option is not provided":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=a.getData();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"when the `raw` option is provided as true, Model::getData() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},{name:"attribute3",raw:function(e,d){return e+" "+d.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2",attribute3:"value3"});var b=a.getData({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned")},"Model::getData() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=a.getData({persistedOnly:true});Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")}}]},{name:"Test getChanges()",ttype:"suite",items:[{"Model::getChanges() should return a single attribute that has had its value changed":function(){var c=Kevlar.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value");var b=a.getChanges();Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 1 property");Y.Assert.areSame("new value",b.attribute1,"The change to attribute1 should have been 'new value'.")},"Model::getChanges() should return multiple attributes that have had their values changed":function(){var c=Kevlar.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value 1");a.set("attribute2","new value 2");var b=a.getChanges();Y.Assert.areSame(2,Kevlar.util.Object.length(b),"The changes hash retrieved should have exactly 2 properties");Y.Assert.areSame("new value 1",b.attribute1,"The change to attribute1 should have been 'new value 1'.");Y.Assert.areSame("new value 2",b.attribute2,"The change to attribute2 should have been 'new value 2'.")},"Model::getChanges() should return the data by running attributes' `get` functions (not just returning the raw data)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},"attribute3"]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data");Y.Assert.isFalse("attribute3" in b,"attribute3 should not exist in the 'changes' data, as it was never changed")},"when the `raw` option is provided as true, Model::getChanges() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Kevlar.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(e,d){return"42 "+d.get("attribute1")}},{name:"attribute3",raw:function(e,d){return e+" "+d.get("attribute1")}},{name:"attribute4",defaultValue:"value4"}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");a.set("attribute3","value3");var b=a.getChanges({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned");Y.Assert.isFalse("attribute4" in b,"attribute4 should not exist in the 'changes' data, as it was never changed")},"Model::getChanges() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) that have been changed when the `persistedOnly` option is set to true":function(){var c=Kevlar.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(1,Kevlar.util.Object.length(b),"The persisted changes should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The persisted changes should only have 'attribute1'")}}]}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Collections",items:[{name:"Test setting nested Collections","set() should only change the attribute that a nested Collection is being set to if it is a different Collection than it already has":function(){var e=Kevlar.Model.extend({attributes:[{name:"nestedCollection",type:"collection"}]});var f=Kevlar.Collection.extend({});var a=new e();var c=new f();var b=new f();var d=0;a.addListener("change:nestedCollection",function(){d++});c.on("add",function(){});b.on("remove",function(){});a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should have been set for the first time");a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should not have been re-set, because it is the same collection that is already there");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new collection (nestedCollection2) should have been set");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");a.set("nestedCollection",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");a.set("nestedCollection",c);Y.Assert.areSame(4,d,"The attribute should have been set to nestedCollection1 after it had been null")}},{name:"Test the 'change' event for embedded collections","When an attribute has changed in a model of an embedded collection, its parent collection should fire the appropriate 'change' events":function(){var e=Kevlar.Model.extend({attributes:["attr"]});var k=Kevlar.Collection.extend({model:e});var n=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"Collection",embedded:true}]});var i=new e({attr:"origValue1"}),h=new e({attr:"origValue2"}),l=new k([i,h]),j=new n({myCollection:l});var d=0,b,p,m,g;j.on("change",function(t,s,u,r){d++;b=t;p=s;m=u;g=r});var o=0,f,q,c,a;j.on("change:myCollection",function(t,s,u,r){o++;f=t;q=s;c=u;a=r});i.set("attr","newValue1");Y.Assert.areSame(1,d,"The call count should now be exactly 1");Y.Assert.areSame(j,b,"The event for childModel1 should have been fired with the model that changed");Y.Assert.areSame("myCollection.attr",p,"The event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame("newValue1",m,"The event for childModel1 should have been fired with the new value");Y.Assert.areSame("origValue1",g,"The event for childModel1 should have been fired with the old value");Y.Assert.areSame(1,o,"The call count should now be exactly 1");Y.Assert.areSame(i,f,"The attribute-specific event for childModel1 should have been fired with the model that changed");Y.Assert.areSame("attr",q,"The attribute-specific event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame("newValue1",c,"The attribute-specific event for childModel1 should have been fired with the new value");Y.Assert.areSame("origValue1",a,"The attribute-specific event for childModel1 should have been fired with the old value")},"When an attribute has changed in a non-embedded collection, its parent model should *not* fire a 'change' event":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var c=Kevlar.Collection.extend({model:d});var e=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:false}]});var h=new d({attr:"origValue1"}),g=new d({attr:"origValue2"}),f=new c([h,g]),a=new e({myCollection:f});var b=0;a.on("change",function(k,j,l,i){b++});h.set("attr","newValue1");Y.Assert.areSame(0,b,"The call count should be 0 - it is not an embedded collection")},"The parent model should no longer fire events from the child collection after the child collection has been un-set from the parent":function(){var d=Kevlar.Model.extend({attributes:["attr"]});var c=Kevlar.Collection.extend({model:d});var e=Kevlar.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:true}]});var h=new d({attr:"origValue1"}),g=new d({attr:"origValue2"}),f=new c([h,g]),a=new e({myCollection:f});var b=0;a.on("change",function(k,j,l,i){if(j==="myCollection.attr"){b++}});h.set("attr","newValue1");Y.Assert.areSame(1,b,"The call count should now be 1 (as an initial test)");a.set("myCollection",null);h.set("attr","newNewValue1");Y.Assert.areSame(1,b,"We should still only have 1 for the event firing count, as we un-set the child model from the parent")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Models",items:[{name:"Test setting nested Models","set() should only change the attribute that a nested Model is being set to if it is a different model than it already has":function(){var f=Kevlar.Model.extend({attributes:[{name:"nestedModel",type:"model"}]});var e=Kevlar.Model.extend({attributes:["attr1","attr2"]});var c=new f();var b=new e();var a=new e();var d=0;c.addListener("change:nestedModel",function(){d++});b.on("change:attr1",function(){});a.on("change:attr1",function(){});c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should have been set for the first time");c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should not have been re-set, because it is the same model that is already there");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should have been set");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");c.set("nestedModel",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");c.set("nestedModel",b);Y.Assert.areSame(4,d,"The attribute should have been set to nestedModel1 after it had been null")}},{name:"Test the 'change' event for embedded models","When an attribute has changed in an embedded model, its parent model should fire the appropriate 'change' events":function(){var k=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var f=new b();var d=new k({child:f});var j=0,i,m,o;d.on("change",function(q,p,r){j++;i=q;m=p;o=r});var n=0,a,h,g;d.on("change:child",function(q,p,r){n++;a=q;h=p;g=r});var e=0,l,c;d.on("change:child.attr",function(p,q){e++;l=p;c=q});f.set("attr","asdf");Y.Assert.areSame(1,j,"The parent's general change event should have fired exactly once");Y.Assert.areSame(d,i,"The parent's general change event should have fired with the parent model");Y.Assert.areSame("child.attr",m,"The parent's general change event should have fired with attributeName as the path to the nested model");Y.Assert.areSame("asdf",o,"The parent's general change event should have fired with the new value");Y.Assert.areSame(1,n,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(f,a,"The childModel-specific change event should have fired with the child model");Y.Assert.areSame("attr",h,"The childModel-specific change event should have fired with attributeName of the changed attribute");Y.Assert.areSame("asdf",g,"The childModel-specific change event should have fired with the new value");Y.Assert.areSame(1,e,"The attribute-specific change event should have fired exactly once");Y.Assert.areSame(f,l,"The attribute-specific change event should have fired with the child model");Y.Assert.areSame("asdf",c,"The attribute-specific change event should have fired with the new value")},"When an attribute has changed in a non-embedded model, its parent model should *not* fire a 'change' event":function(){var d=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:false}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var e=new c();var a=new d({child:e});var b=false;a.on("change",function(){b=true});e.set("attr","asdf");Y.Assert.isFalse(b)},"The parent model should no longer fire events from the child model after the child model has been un-set from the parent":function(){var d=Kevlar.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var c=Kevlar.Model.extend({attributes:[{name:"attr",type:"string"}]});var e=new c();var a=new d({child:e});var b=0;a.on("change",function(f,g,h){if(g==="child.attr"){b++}});e.set("attr","asdf");Y.Assert.areSame(1,b,"while the child model is attached, the change event count should have increased by 1");a.set("child",null);e.set("attr","asdf2");Y.Assert.areSame(1,b,"We should still only have 1 for the event firing count, as we un-set the child model from the parent")},"When an attribute has changed in a deeply nested embedded model, its parent model should fire a 'change' event, with the parentAttr.childAttr.childAttr attributeName":function(){var m=Kevlar.Model.extend({attributes:[{name:"name",defaultValue:"Parent"},{name:"intermediate",type:"model",embedded:true}]});var g=Kevlar.Model.extend({attributes:[{name:"name",defaultValue:"Intermediate"},{name:"child",type:"model",embedded:true}]});var b=Kevlar.Model.extend({attributes:[{name:"name",defaultValue:"Child"},{name:"attr",type:"string"}]});var a=new m(),h=new g(),o=new b();a.set("intermediate",h);h.set("child",o);var s=0,t,f,k;a.on("change",function(w,v,x){s++;t=w;f=v;k=x});var d=0,l,n,u;a.on("change:intermediate",function(w,v,x){d++;l=w;n=v;u=x});var i=0,e,q,p;a.on("change:intermediate.child",function(w,v,x){i++;e=w;q=v;p=x});var c=0,r,j;a.on("change:intermediate.child.attr",function(v,w){c++;r=v;j=w});window.a=true;o.set("attr","asdf");window.a=false;Y.Assert.areSame(1,s,"The general change event should have fired exactly once");Y.Assert.areSame(a,t,"The general change event should have fired with the parent model");Y.Assert.areSame("intermediate.child.attr",f,"The general change event should have fired with the attributeName as the path to the child model's attribute");Y.Assert.areSame("asdf",k,"The general change event should have fired with the new value");Y.Assert.areSame(1,d,"The intermediateModel-specific change event should have fired exactly once");Y.Assert.areSame(h,l,"The intermediateModel-specific change event should have fired with the intermediate model");Y.Assert.areSame("child.attr",n,"The intermediateModel-specific change event should have fired with path to the changed attribute in the deeper child model");Y.Assert.areSame("asdf",u,"The intermediateModel-specific change event should have fired with the new value");Y.Assert.areSame(1,i,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(o,e,"The childModel-specific change event should have fired with the child model");Y.Assert.areSame("attr",q,"The childModel-specific change event should have fired with the attributeName that was changed");Y.Assert.areSame("asdf",p,"The childModel-specific change event should have fired with the new value");Y.Assert.areSame(1,c,"The childModel attribute-specific change event should have fired exactly once");Y.Assert.areSame(o,r,"The childModel attribute-specific change event should have fired with the child model");Y.Assert.areSame("asdf",j,"The childModel attribute-specific change event should have fired with the new value")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ObjectAttribute",items:[{name:"Test defaultValue of ObjectAttribute","The defaultValue for an ObjectAttribute should be null":function(){var b=Kevlar.Model.extend({attributes:[{name:"attr",type:"object"}]});var a=new b();Y.Assert.isNull(a.get("attr"))}}]}));